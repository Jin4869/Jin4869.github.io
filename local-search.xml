<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/01/13/hello-world/"/>
    <url>/2023/01/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CH2 关系数据库</title>
    <link href="/2022/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-关系数据库">第二章 关系数据库</h1><p>典型商用数据库 ORACLE</p><p>关系模型由以下组成：</p><ul><li>关系数据结构：数据的表示（静态特性）</li><li>关系操作集合：基于关系运算</li><li>关系完整性约束：语义有效合理，允许定义</li></ul><h1 id="关系数据结构及形式化定义">1 关系数据结构及形式化定义</h1><h2 id="关系">1.1 关系</h2><ul><li><strong>域</strong><ul><li>一组具有相同数据类型的值的集合</li><li>一个域允许的不同取值个数称为这个域的基数</li></ul></li><li><p><strong>笛卡尔积</strong> <img src="https://img-blog.csdnimg.cn/19d93f059fcc468d87d0c64088f9892e.jpeg#pic_center" alt="在这里插入图片描述" /></p></li><li><strong>关系</strong><ul><li>关系是笛卡尔积的有限子集<ul><li>笛卡尔积不满足交换律，关系满足（每列附加一个属性名取消有序性）</li></ul></li></ul></li></ul><h3 id="候选码">1.1.1 候选码</h3><p>某一属性组的值能唯一的标识一个元组，而其所有子集不能（是最小属性的集合），则称该属性组为<strong>候选码</strong></p><ul><li><strong>主码</strong><ul><li>若一个关系有多个候选码，则选定其中一个为主码</li></ul></li><li><strong>主属性</strong><ul><li>候选码的所有属性称为主属性，<u>不包含在任何候选码</u>的属性称为<strong>非主属性</strong></li></ul></li><li><strong>全码</strong><ul><li><u>关系模式的所有属性</u>是这个关系模式的候选码</li></ul></li></ul><h3 id="三种类型">1.1.2 三种类型</h3><ul><li><strong>基本关系</strong>（默认）<ul><li>通常又称基本表</li><li>实际存在的表，是实际存储数据的逻辑表示</li></ul></li><li><strong>查询表</strong><ul><li>查询结果对应的表</li></ul></li><li><strong>视图表</strong><ul><li>由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</li></ul></li></ul><h3 id="基本关系的-6-条性质">1.1.3 基本关系的 6 条性质</h3><ul><li>列是同质的，每一列中的分量是同一类型的数据，来自同一个域</li><li>不同的列可出自同一个域</li><li>列的次序可以任意交换</li><li>任意两个元组的候选码不能取相同的值（候选码唯一标识一条元组）</li><li>行的次序可以任意交换</li><li>分量必须取原子值，即每一个分量必须是不可分的数据项（最基本）<ul><li>规范化的关系简称为<strong>范式</strong></li></ul></li></ul><h2 id="关系模式">1.2 关系模式</h2><p>关系模式是对关系的描述</p><p><span class="math display">\[R(U, D, DOM, F)\]</span></p><ul><li><strong>R：</strong> 关系名</li><li><strong>U：</strong> 组成该关系的属性名集合，如（学号，姓名。。。）</li><li><strong>D：</strong> U 中属性所来自的域</li><li><strong>DOM：</strong> 属性向域的映像集合</li><li><strong>F：</strong> 属性间数据的依赖关系集合</li></ul><p>关系是关系模式在某一时刻的状态或内容。</p><p>关系模式是<strong>静态的，稳定的</strong>，关系是<strong>动态的，随时间不断变化的</strong>，因为关系操作不断的更新着数据库中的数据</p><h1 id="关系的完整性">2 关系的完整性</h1><p>关系的两个不变性：实体完整性，参照完整性</p><p>保证数据正确（数据库内数据间的相容性和正确性）</p><h2 id="实体完整性">2.1 实体完整性</h2><p><strong>所有码不能取空值</strong></p><h2 id="参照完整性">2.2 参照完整性</h2><p><strong>外码或者取空值或者等于 S 中某个元组的主码值</strong></p><p><strong>外码</strong>：在所在的关系并不是码，但与其他关系有对应关系</p><ul><li><strong>外码属性可以为空</strong>：还未给外码赋值时</li><li><strong>外码属性不可以为空</strong>：外码是主码的一部分，外码被用户定义不能为空</li></ul><h1 id="集合运算">3 集合运算</h1><p><span class="math inline">\(t \in R\)</span> ：t 是 R 的一个元组 <span class="math inline">\(R(A_{1}, A_{2}, ..., A_{n})\)</span> ：</p><ul><li><span class="math inline">\(t[A_{i}]\)</span> 元组 t 的一个分量</li><li><span class="math inline">\(t[A]\)</span> 元组 t 的分量集合</li></ul><p>集合运算：</p><ul><li>并</li><li>交</li><li>差</li><li>笛卡尔积</li></ul><h1 id="关系运算">4 关系运算</h1><p><strong>象集</strong><span class="math inline">\(Z_{x}\)</span> ：R 中属性组 X 上值为 x 的诸元组在 Z 上分量的集合 下表中，<span class="math inline">\(Z_{x_{1}} = \{Z_{1}, Z_{2}, Z_{3}\}\)</span></p><table><thead><tr class="header"><th><span class="math inline">\(x_{1}\)</span></th><th><span class="math inline">\(Z_{1}\)</span></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(x_{1}\)</span></td><td><span class="math inline">\(Z_{2}\)</span></td></tr><tr class="even"><td><span class="math inline">\(x_{1}\)</span></td><td><span class="math inline">\(Z_{3}\)</span></td></tr><tr class="odd"><td><span class="math inline">\(x_{2}\)</span></td><td><span class="math inline">\(Z_{1}\)</span></td></tr><tr class="even"><td><span class="math inline">\(x_{2}\)</span></td><td><span class="math inline">\(Z_{2}\)</span></td></tr><tr class="odd"><td><span class="math inline">\(x_{3}\)</span></td><td><span class="math inline">\(Z_{3}\)</span></td></tr></tbody></table><h2 id="选择">4.1 选择</h2><p><span style="background-color:#C8D5F8"><span class="math display">\[\sigma_{F}(R) = \{ t\mid t \in R \wedge F(t)=&#39;真&#39;\}\]</span></span></p><p>F 表示选择条件，基本形式为<span class="math inline">\(X_{1}\theta Y_{1}\)</span> <span class="math inline">\(\theta\)</span>表示比较运算符，可以是 <span class="math inline">\(&gt;\)</span> ,<span class="math inline">\(&lt;\)</span>等</p><p>实际上是<strong>从关系 R 中选取使逻辑表达式 F 为真的元组</strong>，是从<strong>行角度</strong>进行的运算</p><h2 id="投影">4.2 投影</h2><p><span style="background-color:#C8D5F8"><span class="math display">\[\Pi_{A}(R) = \{ t[A]\mid t \in R \}\]</span></span></p><p>是<strong>从列角度进行的运算</strong></p><p>投影之后不仅取消了原关系中的某些列，<u>还可能取消某些元组</u>，因为取消了某些属性列之后就可能出现重复行，应取消这些完全相同的行</p><h2 id="连接">4.3 连接</h2><p>选取属性间满足一定条件的元组</p><p><span style="background-color:#C8D5F8"><span class="math display">\[R\Join_{A \theta B}S = \{ \widehat{t_{r}t_{s}}\mid t_{r} \in R \wedge t_{s} \in S \wedge t_{r}[A]\theta t_{s}[B] \} \]</span></span></p><p>A 和 B 分别为 R 和 S 上列数相等且可比的属性组</p><p><span class="math inline">\(\theta\)</span>为“=”的连接运算称为<strong>等值连接</strong></p><p><strong>自然连接</strong>：特殊的等值连接，要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉</p><p><strong>同时从行和列的角度进行运算</strong></p><h2 id="除运算-div">4.4 除运算 <span class="math inline">\(\div\)</span></h2><p>蕴涵问题</p><p>选择元组，投影到属性 <img src="https://img-blog.csdnimg.cn/b1c794ead46b412981fa30cf0f121463.jpeg#pic_center" alt="在这里插入图片描述" /></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CH1 绪论</title>
    <link href="/2022/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/"/>
    <url>/2022/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-绪论">第一章 绪论</h1><h2 id="数据库系统概述">数据库系统概述</h2><h3 id="数据">数据</h3><ul><li><strong>数据</strong>是<u>数据库中存储的基本对象</u>，描述事物的符号记录称为数据，有多种表现形式</li><li><strong>特点：</strong> <u>数据的含义称为数据的语义</u>，数据与其语义是不可分的，信息是对数据语义的解释</li></ul><h3 id="数据处理与管理的区别">数据处理与管理的区别</h3><p><strong>数据处理：</strong> 从某些已知的数据推导加工新的数据 <strong>数据管理：</strong> 对数据收集、整理、组织、存储、维护、检索、传送等操作</p><h3 id="数据库">数据库</h3><p><strong>数据库</strong>是<strong>长期存储在计算机内、有组织的、可共享的大量数据的集合。</strong> 数据库中的数据按一定的数据模型组织、描述和储存，具有<u>较小的冗余度，较高的数据独立性和易扩展性</u>（降低更新维护的代价），并可为各种用户共享。</p><h3 id="数据库管理系统---系统软件">数据库管理系统 - 系统软件</h3><p><strong>是位于用户与操作系统之间的一层数据管理软件</strong></p><p>与操作系统一样是计算机的基础软件</p><h4 id="功能">功能</h4><ul><li><strong>数据定义功能：</strong> 提供数据定义语言（DDL），定义数据库中的数据对象</li><li><strong>数据组织、存储和管理：</strong> 基本目标是<u>提高存储空间利用率和方便存取</u>，提供多种存取方法（索引查找，hash 查找，顺序查找）来提高存取效率</li><li><strong>数据操纵功能：</strong> 提供数据操纵语言（DML），基本操作：增删改查</li><li><strong>数据库的事务管理和运行管理：</strong> 在建立、运用和维护的时候统一管理和控制，保证事务的正确运行，发生故障后的系统恢复</li><li><strong>数据库的建立和维护功能：</strong> 初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。</li></ul><h3 id="数据库系统---应用系统">数据库系统 - 应用系统</h3><p><strong>数据库</strong>是<u>由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DBA）组成</u>的<strong>存储、管理、处理和维护数据</strong>的系统</p><h3 id="数据管理技术等产生和发展">数据管理技术等产生和发展</h3><p>三个阶段</p><table><thead><tr class="header"><th></th><th>人工管理阶段</th><th>文件系统阶段</th><th>数据库系统阶段</th></tr></thead><tbody><tr class="odd"><td>软件背景</td><td>没有操作系统</td><td>有文件系统</td><td>有数据库管理系统（DBMS）</td></tr><tr class="even"><td>处理方式</td><td>批处理</td><td>联机实时处理、批处理</td><td>联机实时处理、分布处理、批处理</td></tr><tr class="odd"><td>数据库的管理者</td><td>用户（程序员）</td><td>文件系统</td><td>数据库管理系统</td></tr><tr class="even"><td>数据的共享程度</td><td>无共享，冗余度极大</td><td>共享性差，冗余度大</td><td>共享性高，冗余度小</td></tr><tr class="odd"><td>数据的独立性</td><td>不独立，完全依赖于程序</td><td>独立性差，数据逻辑结构改变要修改应用程序</td><td>具有高度的物理独立性和一定的逻辑独立性</td></tr><tr class="even"><td>数据的结构化</td><td>无结构</td><td>记录内有结构，整体无结构</td><td>整体结构化，用数据模型描述</td></tr><tr class="odd"><td>数据控制能力</td><td>应用程序自己控制</td><td>应用程序自己控制</td><td>由数据库管理系统提供数据安全性、完整性、并发控制能力和恢复能力</td></tr></tbody></table><h3 id="数据库系统特点">数据库系统特点</h3><ul><li><strong>数据结构化：</strong><ul><li>主要特征，也是数据库系统与文件系统的本质区别</li><li><strong>整体结构化：</strong><ul><li>数据库中的数据不再仅仅针对某一个应用，而是面向整个组织或企业</li><li>不仅数据内部是结构化的，而且整体是结构化的，数据之间是有联系的</li></ul></li><li>数据结构用数据模型描述，无需程序定义和解释</li><li>数据可变长，最小单位数据项</li></ul></li><li><strong>数据的共享性高、冗余度低且易扩充：</strong><ul><li><strong>数据共享的好处</strong><ul><li>大大减少数据冗余，节约存储空间</li><li>避免数据之间的不相容性与不一致性</li><li>使数据库系统弹性大，易于扩充</li></ul></li></ul></li><li><strong>数据独立性高：</strong><ul><li><strong>物理独立性：</strong> 用户的应用程序与数据库中数据的物理存储是相互独立的<ul><li>物理存储改变时应用程序不用改变</li></ul></li><li><strong>逻辑独立性：</strong> 用户的应用程序与数据库的逻辑结构是相互独立的<ul><li>逻辑结构改变时用户程序也可以不变</li></ul></li><li>由数据库管理系统提供的二级映像功能保证</li></ul></li><li><strong>数据由数据库管理系统统一管理和控制：</strong> 数据控制功能<ul><li><strong>数据的安全性保护</strong>（主动安全机制-防外部入侵）<ul><li>保护数据以防止不合法使用造成的数据泄密和破坏</li></ul></li><li><strong>数据的完整性检查</strong>（被动安全机制-防内部误操作）<ul><li>完整性指数据的正确性、有效性和相容性，将数据控制在有效范围内</li></ul></li><li><strong>并发控制</strong><ul><li>对并发操作加以协调和控制</li></ul></li><li><strong>数据库恢复</strong></li></ul></li></ul><h4 id="数据库系统的优势">数据库系统的优势</h4><p>使信息系统从以加工数据的程序为中心转向围绕共享的数据库为中心的阶段</p><ul><li>提高了数据的利用率和相容性</li><li>简化应用程序的研制和维护</li><li>便于数据的集中管理</li></ul><h2 id="数据模型">数据模型</h2><p><u>数据模型是对现实世界数据特征的抽象</u>，现实世界用数据模型来抽象、表示和处理。</p><p><strong>数据模型是数据库系统的核心和基础</strong></p><p>根据模型应用的不同目的划分：</p><ul><li><strong>概念模型</strong><ul><li>也称信息模型，按用户的观点对数据和信息建模，主要用于数据库设计</li></ul></li><li><strong>逻辑模型和物理模型</strong> - <strong>逻辑模型：</strong> 按计算机系统的观点对数据建模，主要用于数据库管理系统的实现 - <strong>物理模型：</strong> 数据最底层的抽象，具体是现实数据库管理系统的任务 <img src="assets/16700603684573.jpg" /></li></ul><h3 id="概念模型">概念模型</h3><p>信息世界中的基本概念：</p><ul><li><strong>实体</strong><ul><li>客观存在并可相互区别的事物</li></ul></li><li><strong>属性</strong><ul><li>实体所具有的某一特性称为属性</li><li>若干属性的聚集组成了实体</li><li>属性不能再具有需要描述的性质</li><li>属性不能与其他实体具有联系</li></ul></li><li><strong>域</strong>（domain）<ul><li>属性的取值范围称为该属性的域</li></ul></li><li><strong>码</strong><ul><li>唯一标识实体的属性集称为码（键）</li><li>码是实体属性集的子集</li></ul></li><li><strong>实体型</strong> （class）<ul><li>用实体名及其属性名集合来抽象和刻画同类实体，称为实体型</li></ul></li><li><strong>实体集</strong>（Array/Set）<ul><li>同一类型实体的集合称为实体集</li></ul></li><li><strong>联系</strong><ul><li>实体（型）内部的联系和实体（型）之间的联系</li><li>有一对一，一对多和多对多</li></ul></li></ul><h4 id="表示方法">表示方法</h4><p>E-R 图</p><h3 id="数据模型组成要素背">数据模型组成要素（背）</h3><ul><li><strong>数据结构</strong><ul><li>描述数据库的组成对象以及对象之间的联系</li><li>是所描述的对象类型的集合，是对系统<strong>静态特性</strong>的描述</li></ul></li><li><strong>数据操作</strong><ul><li>对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则</li><li>主要有<strong>查询</strong>和<strong>更新</strong>（包括插入、删除、修改）两大类操作</li><li>是对系统<strong>动态特性</strong>的描述</li></ul></li><li><strong>数据的完整性约束条件</strong><ul><li>是一组完整性规则</li><li>制约和依存规则，保证数据的正确、有效和相容</li></ul></li></ul><h3 id="常用的数据模型">常用的数据模型</h3><ul><li>非关系模型<ul><li><strong>层次模型：</strong> 用树形结构表示各类实体以及实体之间的联系<ul><li>结构简单清晰，查询效率最高</li><li>性能优于关系数据库，不低于网状数据库</li><li>提供了良好的完整性支持</li><li>多对多联系无法用层次模型直接表示</li></ul></li><li><strong>网状模型</strong><ul><li>直接描述现实世界，存取效率较高</li><li>结构比较复杂；不容易掌握，不容易使用</li></ul></li></ul></li><li>关系模型</li><li>面向对象数据模型</li></ul><h4 id="关系模型">关系模型</h4><p>数据结构：</p><ul><li><strong>关系：</strong> 一个关系对应通常说的一张表</li><li><strong>元组：</strong> 表中的一行即为一个元组</li><li><strong>属性：</strong> 表中的一列即为一个属性</li><li><strong>码：</strong> 可以唯一确定一个元组</li><li><strong>域：</strong> 域是一组具有相同数据类型的值的集合</li><li><strong>分量：</strong> 元组中的一个属性值</li><li><strong>关系模式：</strong> 对关系的描述，一般表示为：关系名（属性 1，属性 2...）</li></ul><p>关系模型要求关系必须是规范化的，关系的每一个分量必须是一个不可分的数据项（不允许表中还有表）</p><p>数据操纵：查询、插入、删除、更新</p><p>完整性约束条件：实体完整性（实体可区分（码））、参照完整性（分量存在）、用户定义的完整性（业务逻辑需要）</p><p>优缺点：</p><ul><li>建立在严格的数学概念</li><li>概念单一，所以数据结构简单清晰</li><li>存取路径对用户透明，所以具有更高的数据独立性、更好的安全保密性</li><li>查询效率往往不如格式化数据模型，增加了开发数据库管理系统的难度</li></ul><h2 id="数据库系统模式">数据库系统模式</h2><h3 id="三级模式结构">三级模式结构</h3><p><img src="assets/16700710079279.jpg" /></p><h4 id="模式">模式</h4><p>也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图</p><p>实际上是数据库数据在逻辑集上的视图</p><p><strong>一个数据库只有一个模式</strong></p><p>提供<strong>模式数据定义语言（模式 DDL）</strong> 来严格地定义模式，定义逻辑结构，联系，安全性，完整性要求</p><h4 id="外模式">外模式</h4><p>面向具体应用</p><p>也称子模式或用户模式，是数据库用户能够看见和使用的<strong>局部数据结构和特征的描述</strong>，<u>是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</u></p><p>通常是模式的子集，一个数据库可以有多个外模式。结构、类型、长度、保密级别等都可以不同</p><p>是保证数据库安全性的一个有力措施</p><p>提供<strong>外模式数据定义语言（外模式 DLL）</strong> 来严格定义外模式</p><h4 id="内模式">内模式</h4><p>也称存储模式</p><p><strong>一个数据库只有一个内模式</strong></p><p>是数据<strong>物理结构和存储方式的描述</strong>，是数据在数据库内部的<u>组织方式</u></p><h3 id="二级映像功能">二级映像功能</h3><p><img src="assets/16700725337253.jpg" /></p><h4 id="外模式模式映像---逻辑独立性">外模式/模式映像 -&gt; 逻辑独立性</h4><p><strong>视图级抽象</strong></p><p>描述的是数据的局部逻辑结构</p><h4 id="模式内模式映像---物理独立性">模式/内模式映像 -&gt; 物理独立性</h4><p>模式 - 概念级抽象 内模式 - 物理级抽象</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CH9 并发控制</title>
    <link href="/2022/12/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/12/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="并发控制概述">11.1 并发控制概述</h1><p>事务是并发控制的基本单位</p><p>并发操作带来的数据不一致性 R(x)：读数据 x W(x)：写数据 x</p><p><strong>丢失修改</strong> T2 的提交结果破坏了 T1 的提交结果，导致 T1 的修改被丢失 <img src="assets/16719569047645.jpg" /></p><p><strong>不可重复读</strong></p><ol type="1"><li>T1 读取某一数据，T2 对其做了修改，当事务 T1 再次读该数据，得到与前一次不同的值</li><li>T1 读取某些数据，T2 删除其中部分数据，当 T1 再次读取数据，发现某些记录消失了</li><li>T1 读取某些数据，T2 插入了一些数据，当 T1 再次读取数据，发现多了一些记录</li></ol><p><img src="assets/16719570327616.jpg" /></p><p><strong>读脏数据</strong></p><ul><li>T1 修改某一数据，并将其写回磁盘</li><li>T2 读取同一数据后，T1 由于某种原因被撤销</li><li>这时 T1 已修改过的数据恢复原值，T2 读到的数据就与数据库中的数据不一致</li><li>T2 读到的数据就为“脏”数据，即不正确的数据</li></ul><p><img src="assets/16719582581039.jpg" /></p><h1 id="调度概念">11.2 调度概念</h1><p>调度：“事务集”中的一串有序操作集，一个事务中操作在调度中的顺序应该于他们在事务中的顺序一致</p><p>每个事务最后的行动：COMMIT 和 ROLLBACK</p><p><strong>并发控制的主要技术</strong></p><ul><li><strong>封锁</strong></li><li><strong>时间戳</strong><ul><li>事先选定事务的次序，按照这个时间戳来解决事务的冲突操作</li></ul></li><li><strong>乐观控制法</strong><ul><li>事务提交前再进行正确性检查</li></ul></li></ul><h2 id="封锁">11.1 封锁</h2><ul><li><strong>排他锁（X 锁）</strong><ul><li>若 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其他事务在 T 释放 A 上的锁之前都不能读取和修改 A</li></ul></li><li><strong>共享锁（S 锁）</strong><ul><li>T 能读取 A 不能修改 A，其他事务只能对 A 上 S 锁而不能上 X 锁，直到 T 释放 A 上的 S 锁为止</li></ul></li></ul><h2 id="封锁协议">11.2 封锁协议</h2><ul><li><strong>一级封锁协议</strong><ul><li>事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放</li></ul></li><li><strong>二级封锁协议</strong><ul><li>在一级封锁协议的基础上增加事务 T 在读取数据 R 之前必须对其加 S 锁，读完后即可释放 S 锁</li></ul></li><li><strong>三级封锁协议</strong><ul><li>在一级封锁协议的基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，直到事务结束才释放</li></ul></li></ul><h2 id="活锁和死锁">11.3 活锁和死锁</h2><p><strong>避免活锁</strong>：采取先来先服务原则</p><p>产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待现象</p><p><strong>解决死锁</strong>：</p><ul><li><strong>预防死锁</strong><ul><li>一次封锁法<ul><li>要求每个事务必须一次将所有要使用的数据全部加锁，否则就能继续执行</li></ul></li><li>顺序封锁法<ul><li>预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实施封锁</li></ul></li></ul></li><li><strong>死锁的诊断与解除</strong></li></ul><p><strong>死锁的诊断</strong></p><ul><li><strong>超时法</strong><ul><li>实现简单，但有可能误判死锁，时限设置太长死锁发生后不能及时发现</li></ul></li><li><strong>事务等待图</strong><ul><li>图中存在回路则表示出现死锁 <img src="assets/16719745341914.jpg" /></li></ul></li></ul><p><strong>死锁的解除</strong> 选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有锁，使其他事务得以继续进行下去</p><h2 id="并发调度的可串行性">11.4 并发调度的可串行性</h2><p><strong>可串行化调度</strong>：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。</p><p>可串行性是并发事务正确调度的准则</p><p><strong>冲突操作</strong>：不同的事务对同一个数据的<strong>读写操作</strong>和<strong>写写操作</strong>，其他不冲突</p><p><strong>冲突可串行化调度</strong>：一个调度 Sc 在保证冲突操作的次序不变的情况下，通过<strong>交换两个事务不冲突操作的次序</strong>得到另一调度 Sc'，如果 Sc'是串行的，称调度 Sc 是冲突可串行化的调度</p><p>冲突可串行化一定是可串行化调度，可串行化不一定冲突可串行化</p><blockquote><p>盲目写：在执行 W(Q)之前没有执行 R(Q)的操作，存在于任何不是冲突可串行化的视图可串行化调度中 视图可串行化：两个调度每个事务都读取相同数据从而进行相同的计算</p></blockquote><p><img src="assets/16719754001154.jpg" /></p><h3 id="调度冲突可串行化的判定例题">11.4.1 调度冲突可串行化的判定（例题）</h3><p><img src="assets/16719775145415.jpg" /></p><h2 id="两段锁协议">11.5 两段锁协议</h2><p><strong>第一阶段</strong>：获得封锁，也称为<strong>扩展阶段</strong>，事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁</p><p><strong>第二阶段</strong>：释放封锁，也称为<strong>收缩阶段</strong>，事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁</p><p><img src="assets/16719779921873.jpg" /></p><p>若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的</p><p>一次封锁发遵守两段锁协议</p><p>两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁</p><h2 id="封锁的粒度">11.6 封锁的粒度</h2><p>封锁对象的大小称为<strong>封锁粒度</strong></p><p>封锁的对象：逻辑单元（属性值、属性值集合、元组、关系、索引项、整个索引、整个数据库），物理单元（页、物理记录）</p><ul><li>封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小</li><li>封锁的粒度越小，并发度较高，但系统的开销也就越大</li></ul><h3 id="多粒度树">11.6.1 多粒度树</h3><ul><li>根结点是整个数据库，表示最大的数据粒度</li><li>叶结点表示最小的数据粒度</li></ul><p><img src="assets/16719789204317.jpg" /></p><p>多粒度封锁中一个数据对象可能以两种方式封锁：</p><ul><li>显式封锁<ul><li>直接加到数据对象上的封锁</li></ul></li><li>隐式封锁<ul><li>该数据对象没有独立加锁，是由于其上级节点加锁而使该数据对象加上了锁</li></ul></li></ul><p>对某个数据对象加锁，系统要检查</p><ul><li>该数据对象<ul><li>有无显式封锁与之冲突</li></ul></li><li>所有上级结点<ul><li>检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突：（由上级结点已加的封锁造成的）</li></ul></li><li>所有下级结点<ul><li>看上面的显式封锁是否与本事务的隐式封锁（将加到下级结点的封锁）冲突</li></ul></li></ul><h3 id="意向锁">11.6.2 意向锁</h3><p>目的：提高对某个数据对象加锁时系统的检查效率</p><p>对任一结点加基本锁，需要对上层结点加意向锁</p><p>意向锁类型：</p><ul><li>IS 锁：意向共享锁</li><li>IX 锁：意向排他锁</li><li>SIX 锁：共享意向排他锁<ul><li>例如对某个表加 SIX 锁，则表示该事务要读整个表（S 锁），同时会更新个别元组（IX 锁）</li></ul></li></ul><p><img src="assets/16719795929136.jpg" /></p><p>具有意向锁的多粒度封锁方法</p><ul><li>申请封锁时应该按自上而下的次序进行</li><li>释放封锁时应该按自下而上的次序进行</li></ul><blockquote><p>例如：事务 T1 要对关系 R1 加 S 锁</p><ul><li>要首先对数据库加 IS 锁</li><li>要检查数据库和 R1 是否已加了与 S 不相容的锁（X 或 IX 或 SIX）</li><li>不再需要搜索和检查 R1 中的元组是否加了不相容的锁（X 锁）</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CH8 数据库恢复技术</title>
    <link href="/2022/12/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/12/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="事务的基本概念">10.1 事务的基本概念</h1><p><strong>事务</strong>：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位</p><p>SQL 中定义事务的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span> TRANSACTION;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>事务开始<br><span class="hljs-keyword">COMMIT</span>;             <span class="hljs-operator">/</span><span class="hljs-operator">/</span>提交事务的所有操作，事务正常结束<br>                    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>（将事务中所有对数据库的更新写回到磁盘上的物理数据库中去）<br><span class="hljs-keyword">ROLLBACK</span>;           <span class="hljs-operator">/</span><span class="hljs-operator">/</span>将事务中所有已完成的操作全部撤销，回滚到事务开始的状态<br></code></pre></td></tr></table></figure><h2 id="事务的-acid-特性">10.1.1 事务的 ACID 特性</h2><ul><li><strong>原子性</strong><ul><li>事务是数据库的逻辑工作单位，操作要么都做要么都不做</li></ul></li><li><strong>一致性</strong><ul><li>数据库只包含成功事务提交的结果时，就说明数据库处于一致性状态</li></ul></li><li><strong>隔离性</strong><ul><li>一个事务的执行不能被其他事务干扰</li></ul></li><li><strong>持续性</strong><ul><li>事务一旦提交，对数据库中数据的改变就应该是永久性的</li><li>事务是恢复和并发控制的基本单位</li></ul></li></ul><p>ACID 特性可能遭到破坏的因素：</p><ul><li>不同事务的操作交叉执行</li><li>事务在运行过程中被强行停止</li></ul><h1 id="故障的种类">10.2 故障的种类</h1><ul><li><strong>事务内部的故障</strong><ul><li>运算溢出、并发事务发生死锁而被选中撤销该事务、违反了某些完整性限制而被终止</li><li><strong>UNDO</strong>：事务撤销，强行回滚该事务</li></ul></li><li><strong>系统故障</strong><ul><li>造成系统停止运转的任何事件，使得系统要重新启动，通常称为<strong>软故障</strong>（数据损坏）</li><li>例如：特定类型的硬件错误（CPU 故障）、操作系统故障、DBMS 代码错误、系统断电等</li><li>系统重新启动后，恢复子系统除需要<strong>撤销所有未完成的事务</strong>外，还需要<strong>重做所有已提交的事务</strong>，以将数据库真正恢复到一致状态。</li></ul></li><li><strong>介质故障</strong><ul><li>称为<strong>硬故障</strong>（数据库损坏）</li><li>指外存故障，如硬盘损坏、磁头碰撞、瞬时强磁场干扰等</li></ul></li><li><strong>计算机病毒</strong><ul><li>人为的故障或破坏</li></ul></li></ul><h1 id="恢复的实现技术">10.3 恢复的实现技术</h1><p>恢复的原理：<strong>冗余</strong>，根据存储在系统别处的冗余数据来重建</p><p>建立冗余数据最常用的技术是<strong>数据转储</strong>（备份）和<strong>登记日志文件</strong></p><h2 id="数据转储">10.3.1 数据转储</h2><p>转储即数据库管理员（DBA）定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程，这些备用的数据称为<strong>后备副本</strong>或后援副本</p><p>重装后备副本只能将数据库恢复到转储时的状态</p><ul><li><strong>静态转储</strong><ul><li><strong>实现简单</strong>，转储必须等待正运行的用户事务结束才能运行，新的事务必须等待转储结束才能执行</li><li>得到的一定是一个<strong>数据一致性的副本</strong>；会<strong>降低数据库的可用性</strong></li></ul></li><li><p><strong>动态转储</strong></p><ul><li>转储和用户事务可以并发执行</li><li>转储结束时后备副本上的数据并不能保证正确有效</li></ul></li><li><strong>海量转储</strong><ul><li>每次转储全部数据库</li></ul></li><li><strong>增量转储</strong><ul><li>每次只转储上一次转储后更新过的数据</li></ul></li></ul><h2 id="登记日志文件">10.3.2 登记日志文件</h2><p><strong>日志文件需要登记的内容</strong></p><ul><li>各个事务的开始（BEGIN TRANSACTION）标记</li><li>各个事务的结束（COMMIT 或 ROLLBACK）标记</li><li>各个事务的所有更新操作</li></ul><p><strong>日志记录的内容</strong></p><ul><li>事务标识（标明是哪个事务）</li><li>操作的类型（插入、删除或修改）</li><li>操作对象（记录内部标识）</li><li>更新前数据的旧值（对插入操作而言，此项为空值）</li><li>更新后数据的新值（对删除操作而言，此项为空值）</li></ul><p>利用日志文件恢复 <img src="assets/16719542905530.jpg" /></p><p>日志文件可以用来进行事务故障恢复和系统故障恢复，并协助后备副本进行介质故障恢复</p><p><strong>登记日志文件需要遵循的两条原则</strong></p><ul><li>登记的次序严格按并发事务执行的时间次序</li><li>必须先写日志文件，后写数据库</li></ul><h1 id="恢复策略">10.4 恢复策略</h1><table><thead><tr class="header"><th>故障</th><th>恢复策略</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>事务故障</td><td>UNDO</td><td></td></tr><tr class="even"><td>系统故障</td><td>UNDO（故障发生前未完成的事务）+REDO（已完成的事务，完成可能还在缓冲区没存到磁盘）</td><td></td></tr><tr class="odd"><td>介质故障</td><td>重装备份到一致状态+REDO</td><td>对于静态转储，装入最新的数据库后备副本即恢复一致性；对于动态转储，还需同时装入转储开始时刻的日志文件副本，REDO+UNDO，才能恢复一致性状态；需要数据库管理员的介入</td></tr></tbody></table><h1 id="具有检查点的恢复技术">10.5 具有检查点的恢复技术</h1><p>增加一个<strong>重新开始文件</strong></p><p><strong>检查点记录内容</strong>包括：</p><ul><li>建立检查点时刻所有正在执行的事务清单</li><li>这些事务最近一个日志揭露的地址</li></ul><p><strong>重新开始文件</strong>用来记录各个检查点记录在日志文件中的地址</p><p><img src="assets/16719556905762.jpg" /></p><p><img src="assets/16719557187660.jpg" /></p><h1 id="数据库镜像">10.6 数据库镜像</h1><p>实际应用中用户往往只选择对关键数据和日志文件进行镜像，而不是对整个数据库进行镜像</p><p>主数据库负责数据的更新</p><p><img src="assets/16719559584876.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>SQL语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CH7 数据库设计</title>
    <link href="/2022/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="第七章-数据库设计">第七章 数据库设计</h1><h2 id="数据库设计概述">7.1 数据库设计概述</h2><p>数据库设计的特点“三分技术，七分管理，十二分基础数据”</p><h3 id="数据库设计的六个阶段熟练掌握">7.1.1 数据库设计的六个阶段（熟练掌握）</h3><ul><li><strong>需求分析</strong><ul><li>准确了解与分析用户需求（包括数据与处理）</li><li>最困难、最耗费时间的一步</li></ul></li><li><strong>概念结构设计</strong><ul><li>整个数据库设计的关键</li><li>形成一个独立于具体数据库管理系统的概念模型</li></ul></li><li><strong>逻辑结构设计</strong><ul><li>将概念结构转换为某个 DBMS 所支持的数据模型</li><li>优化</li></ul></li><li><strong>物理结构设计</strong><ul><li>为逻辑结构选取一个最适合应用环境的物理结构（包括存储结构和存取方法）</li></ul></li><li><strong>数据库实施</strong><ul><li>建立数据库</li><li>编制与调试应用程序</li><li>组织数据入库</li><li>进行试运行</li></ul></li><li><strong>数据库运行和维护</strong><ul><li>经过试运行即可投入正式运行</li><li>运行过程中不断进行评估、调整与修改</li></ul></li></ul><p><strong>需求分析和概念设计独立于任何数据库管理系统</strong></p><p>逻辑设计和物理设计与选用的 DBMS 密切相关</p><p><img src="assets/16718867044639.jpg" /> 图：数据库设计各个阶段的设计描述</p><h3 id="数据库设计过程中的各级模式">7.1.2 数据库设计过程中的各级模式</h3><p><img src="assets/16718869311421.jpg" /></p><h2 id="需求分析">7.2 需求分析</h2><h3 id="需求分析过程">7.2.1 需求分析过程</h3><p><img src="assets/16718872124515.jpg" /></p><h3 id="数据字典">7.2.2 数据字典</h3><p><strong>用途</strong>：进行详细的数据收集和数据分析所获得主要成果</p><p>数据字典是关于数据库中数据的描述，是<strong>元数据</strong>，而不是数据本身，在<strong>需求分析</strong>阶段建立，<strong>强调用户的参与</strong></p><p><strong>内容</strong></p><ul><li><strong>数据项</strong><ul><li>不可再分的数据单位</li><li>数据项描述 = {数据项名，数据项含义说明，别名，数据类型，长度，取值范围，取值含义，与其他数据项的逻辑关系，数据项之间的联系}<ul><li>“取值范围”、“与其他数据项的逻辑关系”定义了数据的完整性约束条件</li></ul></li></ul></li><li><strong>数据结构</strong><ul><li>数据之间的组合关系</li><li>数据结构描述 = {数据结构名，含义说明，组成：{数据项或数据结构}}</li></ul></li><li><strong>数据流</strong><ul><li>数据结构在系统内传输的路径</li><li>数据流描述 = {数据流名，说明，数据流来源，数据流去向，组成：{数据结构}，平均流量，高峰期流量}</li></ul></li><li><strong>数据存储</strong><ul><li>数据结构停留或保存的地方，也是数据流的来源和去向之一</li><li>数据存储描述 = {数据存储名，说明，编号，输入的数据流，输出的数据流，组成：{数据结构}，数据量，存取频度，存取方式}</li></ul></li><li><strong>处理过程</strong><ul><li>一般用判定表或判定树来描述</li><li>处理过程描述 = {处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}}</li></ul></li></ul><h2 id="概念结构">7.3 概念结构</h2><h3 id="e-r-模型">7.3.1 *E-R 模型</h3><pre><code class=" mermaid">graph TB实体集a([属性])b&#123;联系集&#125;</code></pre><h3 id="概念结构设计">7.3.2 概念结构设计</h3><p>为了简化 E- R 图的处置，现实世界的事物能作为属性对待的尽量作为属性对待</p><ul><li>作为属性不能再具有需要描述的性质</li><li>属性不能与其他实体具有联系</li></ul><ol type="1"><li>合并 E-R 图。生成初步的 E-R 图 产生冲突：<ul><li>属性冲突</li><li>命名冲突</li><li>结构冲突</li></ul></li><li>消除不必要的冗余，设计基本 E-R 图<ul><li>冗余容易破坏数据库的完整性，给数据库维护增加困难</li></ul></li></ol><h2 id="逻辑结构">7.4 逻辑结构</h2><p>把概念结构设计阶段设计好的基本 E-R 图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构</p><h3 id="转化规则">7.4.1 转化规则：</h3><ul><li>一个实体型转换为一个独立的关系模式</li><li>1:1 联系可以与任何一端的关系模式合并</li><li>1:n 联系一般和多端合并，放上 1 端的候选码</li><li>m:n 转换成一个独立的关系模式</li><li>三个或三个以上实体间的一个多元联系可以转换为一个关系模式</li></ul><h3 id="数据模型的优化">7.4.2 数据模型的优化</h3><p>对关系模式进行必要分解，提高数据操作效率和存储空间利用率。常用的两种分解方法是<strong>水平分解</strong>和<strong>垂直分解</strong></p><h2 id="物理结构">7.5 物理结构</h2><p>关系模式常用<strong>存取方法</strong>：<u>索引方法</u>和<u>聚簇方法</u></p><p>B+树索引和 hash 索引是数据库中经典的存取方法</p><h2 id="例题">7.6 例题</h2><p><img src="assets/16718901231457.jpg" /></p><h2 id="第七章相关习题">第七章相关习题</h2><ol type="1"><li>在数据库设计中，把数据需求写成文档，它是个类数据描述的集合，包括数据项、数据结构、数据流、数据存储和数据加工过程等的描述，通常称为 <u>数据字典</u></li><li>E- R 图向关系模型转化要解决的问题是如何将实体和实体之间的的联系转换成关系模式，并如何确定这些关系模式的<u>属性</u>和<u>码</u></li><li>为提高数据操作的效率和存储空间的利用率，经过规范化处理之后的关系模式还需要进行一定的优化处理。优化是根据需求分析和概念设计中定义的事务的特点对关系模式进行必要的分解，常用的两种分解方法是<u>水平分解</u>和<u>垂直分解</u></li><li>将概念模型转换为全局逻辑模型后，还需根据局部应用需求，结合具体 DBMS 的特点，设计<u>用户的外模式（或用户视图）</u></li><li>E-R 图是数据库设计的工具之一，它适用于建立数据库的<u>概念模型</u></li><li>数据库逻辑设计阶段的任务是<u>建立数据模型</u></li><li>数据流程图（DFD）是用于描述结构化方法中<u>需求分析</u>阶段的工具</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>数据库设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CH6 关系数据理论</title>
    <link href="/2022/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/"/>
    <url>/2022/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="规范化">6.1 规范化</h1><h2 id="函数依赖">6.1.1 函数依赖</h2><p>（R(U)是属性集 U 上的关系模式，X，Y 是 U 的子集）<strong>X 函数确定 Y 或 Y 函数依赖于 X</strong>，记作<span class="math inline">\(X\to Y\)</span></p><blockquote><p>只能根据语义来确定一个函数依赖，例如：姓名-&gt;年龄这个函数依赖只有在该部门没有同名人的条件下成立，如果允许有同名人，则年龄就不再函数依赖于姓名</p><p>一些术语和记号：</p></blockquote><ul><li><span class="math inline">\(X\to Y\)</span>，但<span class="math inline">\(Y\nsubseteq X\)</span>，则称<span class="math inline">\(X\to Y\)</span>是<strong>非平凡</strong>的函数依赖，反之称为平凡的函数依赖<ul><li><blockquote><p>平凡依赖是必然成立的，我们总是讨论非平凡的函数依赖</p></blockquote></li></ul></li><li>若<span class="math inline">\(X \to Y\)</span>，则称 X 是<strong>决定因素</strong></li><li>若<span class="math inline">\(X \to Y\)</span>，<span class="math inline">\(Y \to X\)</span>，则记作<span class="math inline">\(X \leftarrow \to Y\)</span></li><li>若 Y 不函数依赖于 X，记作<span class="math inline">\(X \nrightarrow Y\)</span></li><li><strong>完全函数依赖：</strong> Y 依赖于 X 但是不依赖于 X 的任何一个真子集，记作<span class="math inline">\(X \to^F Y\)</span></li><li><strong>部分函数依赖：</strong> Y 对 X 的子集依赖，记作<span class="math inline">\(X\to ^PY\)</span></li><li><strong>传递函数依赖：</strong> <span class="math inline">\(X \to Y(Y \nsubseteq X), Y\nrightarrow X, Y \to Z,Z \nsubseteq Y\)</span><ul><li><blockquote><p>这里加上条件<span class="math inline">\(Y \nrightarrow X\)</span>，因为如果<span class="math inline">\(Y\to X\)</span>，则<span class="math inline">\(X\leftarrow \to Y\)</span>，实际上就是<span class="math inline">\(X \to ^{直接} Y\)</span>，是直接函数依赖而不是传递函数依赖</p></blockquote></li></ul></li></ul><h2 id="码">6.1.2 码</h2><ul><li><strong>候选码：</strong> 设 K 为 R(U,F)中的属性或属性集合，若 U 对 K 完全函数依赖，则 K 为 R 的候选码</li><li><strong>超码：</strong> U 部分依赖于 K。<strong>候选码是最小的超码</strong></li><li><strong>主码</strong>：若候选码多余一个，则选定其中的一个为主码</li><li><strong>主属性：</strong> 包含在任何一个候选码中的属性</li><li><strong>全码</strong>：整个属性组是码</li><li><strong>外码</strong>：关系模式 R 中属性或属性组<strong>X 并非 R 的码</strong>，但<strong>X 是另外一个关系模式的码</strong>，则称 X 是 R 的外码</li></ul><h2 id="范式">6.1.3 范式</h2><h3 id="nf">6.1.3.1 2NF</h3><p>每一个非主属性完全函数依赖于（不部分依赖于）任何一个候选码</p><h3 id="nf-1">6.1.3.2 3NF</h3><p>每一个非主属性既不不传递依赖于码，也不部分依赖于码</p><h3 id="bcnf">6.1.3.3 BCNF</h3><p>每一个决定因素都包含码</p><p><strong>若 3NF 只有唯一候选吗，则一定为 BCNF</strong></p><p><strong>全主属性一定可达 3NF，全码一定可达 BCNF</strong></p><h3 id="多值依赖">6.1.3.4 多值依赖</h3><p>R(U)是属性集 U 上的一个关系模式，X，Y，Z 是 U 的子集，并且 U=X+Y+Z，如果<strong>一个 X 的值决定一组 Y 的值</strong>，则<strong>多值依赖</strong><span class="math inline">\(X\to\to Y\)</span>成立</p><ul><li><strong>平凡多值依赖：</strong> Z 为空集，即 U=X+Y，且多值依赖<span class="math inline">\(X\to\to Y\)</span>成立</li><li><strong>非平凡多值依赖：</strong> Z 非空</li></ul><p>函数依赖可以看作是多值依赖的特殊情况</p><blockquote><p>多值依赖<span class="math inline">\(X\to\to Y\)</span>若在 R(U)上成立，不能断言对于任何<span class="math inline">\(Y&#39;\subset Y\)</span>有<span class="math inline">\(X\to\to Y&#39;\)</span>成立</p></blockquote><h3 id="nf-2">6.1.3.5 4NF</h3><p>不允许有非平凡且非函数依赖的多值依赖</p><p>4NF 所允许的非平凡的多值依赖实际上就是函数依赖</p><p><strong>若一个关系模式为 4NF，则必为 BCNF</strong></p><p><strong>4NF 中：</strong></p><ul><li>非平凡的多值依赖<ul><li>x 含码 -&gt; 多值依赖也是函数依赖</li></ul></li><li>平凡的多值依赖<ul><li>x 含码 -&gt; 是函数依赖</li><li>x 不含码 -&gt; 不是函数依赖</li></ul></li></ul><p><img src="assets/16718706867902.jpg" /></p><h3 id="例题判断范式">6.1.3.6 例题：判断范式</h3><p><img src="assets/16718718543485.jpg" /></p><h1 id="数据依赖的公理系统-armstrong-公理系统">6.2 数据依赖的公理系统 armstrong 公理系统</h1><p><strong>F 逻辑蕴涵<span class="math inline">\(X \to Y\)</span></strong>:关系模式 R&lt;U, F&gt;中，函数依赖<span class="math inline">\(X\to Y\)</span>成立</p><ul><li>有效性：由 F 出发依据公理推出的每个函数依赖一定在<span class="math inline">\(F^+\)</span>中</li><li>完备性：<span class="math inline">\(F^+\)</span>中每个函数依赖一定可以由 F 出发根据公理推导出来</li></ul><h2 id="推理规则">6.2.1 推理规则</h2><p>对 R&lt;U, F&gt;有以下推理规则：</p><ul><li><strong>自反律：</strong><ul><li>若<span class="math inline">\(Y \subseteq X \subseteq U\)</span>，则<span class="math inline">\(X \to Y\)</span>为 <span class="math inline">\(F\)</span> 所蕴涵</li><li>子集对全集一定有平凡函数依赖</li><li>自反律得到的函数依赖均是平凡的函数依赖，自反律的使用并不依赖于 F</li></ul></li><li><strong>增广律：</strong><ul><li>若<span class="math inline">\(X \to Y\)</span>为 <span class="math inline">\(F\)</span> 所蕴涵，且<span class="math inline">\(Z \subseteq U\)</span>，则 <span class="math inline">\(XZ \to YZ\)</span> 为 <span class="math inline">\(F\)</span> 所蕴涵</li><li>左右各加了一个属性</li></ul></li><li><strong>传递律：</strong><ul><li>若<span class="math inline">\(X \to Y\)</span>及<span class="math inline">\(Y \to X\)</span> 为 <span class="math inline">\(F\)</span> 所蕴涵，则<span class="math inline">\(X \to Z\)</span>为 F 所蕴涵</li><li>如果<span class="math inline">\(Y \to X, X\to Y\)</span>，则符合传递律但不符合传递函数依赖</li></ul></li><li><strong>合并规则</strong><ul><li>由<span class="math inline">\(X\to Y\)</span>,<span class="math inline">\(X \to Z\)</span>，有<span class="math inline">\(X \to YZ\)</span></li></ul></li><li><strong>伪传递规则</strong><ul><li>由<span class="math inline">\(X \to Y\)</span>, <span class="math inline">\(WY \to Z\)</span>，有<span class="math inline">\(XW \to Z\)</span></li></ul></li><li><strong>分解规则</strong><ul><li>由<span class="math inline">\(X \to Y\)</span>,<span class="math inline">\(Z \subseteq Y\)</span>，有<span class="math inline">\(X \to Z\)</span></li></ul></li></ul><h2 id="闭包">6.2.2 闭包</h2><p><span class="math inline">\(F^+\)</span>：F 的闭包，F 所逻辑蕴含的函数依赖的全体</p><h3 id="求闭包的步骤">6.2.2.1 求闭包的步骤</h3><ol type="1"><li>所有空集依赖</li><li>自身依赖，然后增广律扩充</li><li>原本关系增光扩充</li></ol><p><span class="math inline">\(X^+_F\)</span>：属性集 X 关于函数依赖集 F 的闭包（左边全是 X 的函数依赖）</p><blockquote><p>求候选码：一组属性集的闭包是全集</p></blockquote><h3 id="求属性集-x-闭包的算法">6.2.2.2 求属性集 X 闭包的算法</h3><ol type="1"><li>令<span class="math inline">\(X^0 = X\)</span>，<span class="math inline">\(i=0\)</span></li><li>求 B，此时 B 为函数依赖中左边为<span class="math inline">\(X^i\)</span>的函数依赖的右边部分的集合</li><li><span class="math inline">\(X^{i+1} = B \cup X^i\)</span></li><li>判断<span class="math inline">\(X^{i+1} = X^i\)</span></li><li>如果相等或等于 U，则<span class="math inline">\(X^i\)</span>就是<span class="math inline">\(X^+_F\)</span>，算法终止</li><li>若否，则<span class="math inline">\(i = i+1\)</span>，返回第二步（就是把 B 合并进去了）</li></ol><blockquote><p>不在函数依赖右边出现的属性一定是候选码组成部分</p></blockquote><h3 id="等价与最小覆盖">6.2.2.3 等价与最小覆盖</h3><ul><li><strong>函数依赖集等价</strong><ul><li>如果<span class="math inline">\(G^+ = F^+\)</span>，就说函数依赖集 F 覆盖 G（F 是 G 的覆盖，或 G 是 F 的覆盖），或 F 与 G 等价</li></ul></li><li><strong>最小依赖集/最小覆盖</strong><span class="math inline">\(F_m\)</span><ul><li>F 中任一函数依赖的右部仅含有一个属性</li><li>不存在冗余的函数依赖</li><li>函数依赖左部要尽可能简（不能再用子集替代）</li></ul></li></ul><h3 id="求最小依赖集的方法">6.2.2.4 求最小依赖集的方法</h3><ol type="1"><li>判断右边，分解右端</li><li>去冗余函数依赖</li><li>判断左边，左边如果有多属性值，用子集代替之后判断是否保持函数依赖</li></ol><blockquote><p><span class="math inline">\(F_m不一定是唯一的\)</span></p><p><strong>例：</strong></p></blockquote><p><img src="assets/16718722127099.jpg" /></p><h1 id="模式分解">6.3 模式分解</h1><p><strong>投影：</strong> 函数依赖集合 <span class="math inline">\(\\{ X \to Y|X\to Y\in F^+ \wedge XY\subseteq U_i\\}\)</span> 的一个覆盖 <span class="math inline">\(F_i\)</span> 叫做 <span class="math inline">\(F\)</span> 在属性 <span class="math inline">\(U_i\)</span> 上的投影</p><ul><li><strong>无损连接性</strong> 保证不丢失信息</li><li><strong>保持函数依赖性</strong> 减轻或解决各种异常情况</li></ul><h2 id="题型-1判断是否保持函数依赖和无损连接性">题型 1:判断是否保持函数依赖和无损连接性</h2><p><strong>例一</strong> <img src="assets/16718731711350.jpg" /></p><hr /><p><strong>例二</strong> （有隐藏的函数依赖，注意判断）</p><p><img src="assets/16718733465879.jpg" /></p><h2 id="题型-2模式分解">题型 2:模式分解</h2><p><strong>判断是否需要分解的理由（一般是分解到 3NF）</strong></p><p>范式太低，会存在插入、修改、删除数据的异常</p><h3 id="分解为-3nf">1:分解为 3NF</h3><p><img src="assets/16718726837430.jpg" /></p><h3 id="分解为-bcnf">2:分解为 BCNF</h3><p><strong>例一</strong></p><p><img src="assets/16718728492261.jpg" /></p><hr /><p><strong>例二</strong> （损失了函数依赖）</p><p><img src="assets/16718729190952.jpg" /></p><h3 id="分解为-4nf">3:分解为 4NF</h3><p><strong>例一</strong></p><p><img src="assets/16718730468843.jpg" /></p><hr /><p><strong>例二</strong> （损失函数依赖）</p><p><img src="assets/16718730707856.jpg" /></p><h2 id="总结">6.3.1 总结</h2><ul><li>若要求分解具有<strong>无损连接性</strong>，模式分解一定可达 4NF（函数依赖范畴一定可达 BCNF）</li><li>若要求分解保持<strong>函数依赖</strong>，模式分解一定可达 3NF，不一定可达 BCNF</li><li>若要求分解<strong>既保持函数依赖又具有无损连接性</strong>，模式分解一定可达 3NF，不一定可达 BCNF</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>关系数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CH3 SQL</title>
    <link href="/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%89%E7%AB%A0-SQL/"/>
    <url>/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%89%E7%AB%A0-SQL/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-关系数据库标准语言-sql">第三章 关系数据库标准语言 SQL</h1><h2 id="sql-动词">SQL 动词</h2><table><thead><tr class="header"><th>SQL 功能</th><th>动词</th></tr></thead><tbody><tr class="odd"><td>数据查询</td><td>SELECT</td></tr><tr class="even"><td>数据定义</td><td>CREATE、DROP、ALTER</td></tr><tr class="odd"><td>数据操纵</td><td>INSERT、UPDATE、DELETE</td></tr><tr class="even"><td>数据控制</td><td>GRANT、REVOKE</td></tr></tbody></table><h2 id="数据定义">数据定义</h2><h3 id="模式的定义和删除">模式的定义和删除</h3><h4 id="定义">定义</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">AUTHORIZATION</span> <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>表定义子句<span class="hljs-operator">&gt;</span><span class="hljs-operator">|</span><span class="hljs-operator">&lt;</span>视图定义子句<span class="hljs-operator">&gt;</span><span class="hljs-operator">|</span><span class="hljs-operator">&lt;</span>授权定义子句<span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure><p>如果没有指定模式名，那么模式名隐含用户名</p><p><strong>例：为用户 ZHANG 创建一个模式 TEST，并在其中定义一个表 TAB1</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA TEST <span class="hljs-keyword">AUTHORIZATION</span> ZHANG  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建模式<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> TAB1(                      <span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建表<br>            COL1 <span class="hljs-type">INT</span>,<br>            COL2 <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>)<br>            );<br></code></pre></td></tr></table></figure><h4 id="删除">删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>CASCADE<span class="hljs-operator">|</span>RESTRICT<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>CASCADE</code> <strong>级联</strong>，表示删除模式时同时把该模式中所有数据库对象全部删除</li><li><code>RESTRICT</code> <strong>限制</strong>，如果该模式已经定义了下属的数据库对象（表、视图等），则拒绝该语句执行</li></ul><h3 id="基本表">基本表</h3><h4 id="定义-1">定义</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> (<br>    <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [列级完整性约束条件]<br>    [<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [列级完整性约束条件]]<br>    ...<br>    [,<span class="hljs-operator">&lt;</span>表级完整性约束条件<span class="hljs-operator">&gt;</span>]);<br></code></pre></td></tr></table></figure><p><strong>例：建立学生选课表 SC</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> SC(<br>    Sno <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>),<br>    Cno <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>),]<br>    Grade <span class="hljs-type">SMALLINT</span>,     <span class="hljs-comment">/*短整数，2字节*/</span><br>    <span class="hljs-keyword">PRIMARY</span> KEY (Sno, Cno),<br>        <span class="hljs-comment">/*主码由两个属性构成，必须作为表级完整性进行定义*/</span><br>    <span class="hljs-keyword">FOREIGN</span> KEY (Sno) <span class="hljs-keyword">REFERENCES</span> Student(Sno),<br>        <span class="hljs-comment">/*表级完整性约束条件，Sno是外码，被参照表是Student*/</span><br>    <span class="hljs-keyword">FOREIGN</span> KEY (Cno) <span class="hljs-keyword">REFERENCES</span> Course(Cno)<br>        <span class="hljs-comment">/*表级完整性约束条件，Cno是外码，被参照表是Course*/</span><br>    );<br></code></pre></td></tr></table></figure><p><strong>数据类型</strong></p><table><thead><tr class="header"><th>数据类型</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>CHAR(n)</td><td>长度为 n 的定长字符串</td></tr><tr class="even"><td>VARCHAR(n)</td><td>最大长度为 n 的变长字符串</td></tr><tr class="odd"><td>CLOB</td><td>字符串大对象</td></tr><tr class="even"><td>BLOB</td><td>二进制大对象</td></tr><tr class="odd"><td>INT</td><td>长整数（4 字节）</td></tr><tr class="even"><td>SMALLINT</td><td>短整数（2 字节）</td></tr><tr class="odd"><td>BIGINT</td><td>大整数（8 字节）</td></tr><tr class="even"><td>NUMERIC(p, d)</td><td>定点数，总共 p 位数字，小数点后 d 位数字</td></tr><tr class="odd"><td>FLOAT(n)</td><td>精度至少为 n 位数字的浮点数</td></tr><tr class="even"><td>BOOLEAN</td><td>逻辑布尔量</td></tr><tr class="odd"><td>DATE</td><td>日期，YYYY-MM-DD</td></tr><tr class="even"><td>TIME</td><td>时间，HH:MM:SS</td></tr><tr class="odd"><td>TIMESTAMP</td><td>时间戳类型</td></tr></tbody></table><h4 id="修改">修改</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">COLUMN</span>] <span class="hljs-operator">&lt;</span>新列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [完整性约束]]<br>        <span class="hljs-comment">/*增加新列、新列级完整性*/</span><br>[<span class="hljs-keyword">ADD</span> <span class="hljs-operator">&lt;</span>表级完整性约束<span class="hljs-operator">&gt;</span>]<br>        <span class="hljs-comment">/*增加新的表完整性约束*/</span><br>[<span class="hljs-keyword">DROP</span> [<span class="hljs-keyword">COLUMN</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [CASCADE<span class="hljs-operator">|</span>RESTRICT]]<br>        <span class="hljs-comment">/*删除列。RESTRICT表示如果该列被其他对象引用则拒绝删除，CASCADE表示自动删除引用了该列的其他对象*/</span><br>[<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-operator">&lt;</span>完整性约束名<span class="hljs-operator">&gt;</span> [RESTRICT<span class="hljs-operator">|</span>CASCADE]]<br>        <span class="hljs-comment">/*删除指定的完整型约束条件*/</span><br>[<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span>]<br>        <span class="hljs-comment">/*修改原有的列定义，包括修改列名和数据类型*/</span><br></code></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*向Student表增加“S_entrance”列，数据类型为DATE*/</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student <span class="hljs-keyword">ADD</span> S_entrance <span class="hljs-type">DATE</span>;<br><br><span class="hljs-comment">/*将年龄(Sage)的数据类型由字符型改为整数*/</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> Sage <span class="hljs-type">INT</span>;<br><br><span class="hljs-comment">/*增加课程名称(Cname)必须取唯一值的约束条件*/</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Course <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span>(Cname);<br></code></pre></td></tr></table></figure><h4 id="删除-1">删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> [RESTRICT<span class="hljs-operator">|</span>CASCADE];<br></code></pre></td></tr></table></figure><ul><li><code>RESTRICT</code>（默认情况）: 欲删除的基本表不能被其他表的约束所引用（如 CHECK，FOREIGN KEY 等），不能有视图，不能有触发器，不能有存储过程或函数</li><li><code>CASCADE</code> 删除没有限制，相关的依赖对象比如视图都会被删</li></ul><h3 id="索引">索引</h3><p>常见索引包括顺序文件上的索引、B+树索引，散列（hash）索引，位图索引</p><p>维护索引由 DBMS 自动完成</p><h4 id="建立">建立</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="hljs-operator">&lt;</span>索引名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>(<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>次序<span class="hljs-operator">&gt;</span>] [,<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>[<span class="hljs-operator">&lt;</span>次序<span class="hljs-operator">&gt;</span>]]...)<br></code></pre></td></tr></table></figure><p>次序：ASC(升序，默认)，DESC(降序)</p><ul><li><code>UNIQUE</code> 此索引的每一个索引值只对应唯一的数据记录</li><li><code>CLUSTER</code> 表示要建立的索引是聚簇索引<ul><li>物理排序，在最常查询且少更新的列上进行</li><li>一个基本表最多一个聚簇索引</li></ul></li></ul><h4 id="修改-1">修改</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> INDEX <span class="hljs-operator">&lt;</span>旧索引名<span class="hljs-operator">&gt;</span> RENAME <span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>新索引名<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h4 id="删除-2">删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX <span class="hljs-operator">&lt;</span>索引名<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h3 id="数据字典">数据字典</h3><p>关系数据库管理系统内部的一组系统表，记录了数据库中所有的定义信息。</p><p>执行 SQL 的数据定义语句时，实际上就是在跟新数据字典表中的相应信息，在进行查询优化和查询处理时，数据字典中的信是最重要的依据</p><h2 id="数据查询">数据查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-keyword">ALL</span><span class="hljs-operator">|</span><span class="hljs-keyword">DISTINCT</span>] <span class="hljs-operator">&lt;</span>目标列表达式<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>目标列表达式<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名或视图名<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>表名或视图名<span class="hljs-operator">&gt;</span>...]<span class="hljs-operator">|</span>(<span class="hljs-keyword">SELECT</span> 语句)[<span class="hljs-keyword">AS</span>]<span class="hljs-operator">&lt;</span>别名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件表达式<span class="hljs-operator">&gt;</span>]<br>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">HAVING</span> <span class="hljs-operator">&lt;</span>条件表达式<span class="hljs-operator">&gt;</span>]]<br>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>]]<br></code></pre></td></tr></table></figure><ul><li>DISTINCT：取值唯一</li><li>GROUP BY：分组</li></ul><h3 id="单表查询">单表查询</h3><h4 id="选择表中若干列">选择表中若干列</h4><h5 id="查询指定列">查询指定列</h5><p><strong>例：查询全体学生的姓名、学号、所在系</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname,Sno,Sdept<br><span class="hljs-keyword">FROM</span> Student;<br></code></pre></td></tr></table></figure><h5 id="查询所有列">查询所有列</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Student;<br></code></pre></td></tr></table></figure><h5 id="查询经过计算的值">查询经过计算的值</h5><p><strong>例：查询全体学生姓名及其出生年份</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname,<span class="hljs-number">2022</span><span class="hljs-operator">-</span>Sage  <span class="hljs-comment">/*&quot;2022-Sage&quot;是一个算数表达式*/</span><br><span class="hljs-keyword">FROM</span> Student;<br></code></pre></td></tr></table></figure><p><strong>目标列表达式还可以是字符串常量（整列都是那个常量），函数</strong></p><h5 id="通过指定别名来改变查询结果的列标题">通过指定别名来改变查询结果的列标题</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname NAME,<br>        <span class="hljs-string">&#x27;Year of Birth:&#x27;</span> BIRTH,<br>        <span class="hljs-number">2022</span><span class="hljs-operator">-</span>Sage BIRTHDAY,<br>        <span class="hljs-built_in">LOWER</span>(Sdept) DEPARTMENT <span class="hljs-comment">/*将Sdept改为小写*/</span><br><span class="hljs-keyword">FROM</span> Student;<br></code></pre></td></tr></table></figure><p>结果：</p><table><thead><tr class="header"><th>NAME</th><th>BIRTH</th><th>BIRTHDAY</th><th>DEPARTMENT</th></tr></thead><tbody><tr class="odd"><td>李勇</td><td>Year of Birth:</td><td>1994</td><td>cs</td></tr></tbody></table><h4 id="选择表中若干元组">选择表中若干元组</h4><h5 id="消除取值重复的行-distinct">消除取值重复的行 DISTINCT</h5><p>DISTINCT 作用范围是<u>所有目标列</u></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> Sno<br><span class="hljs-keyword">FROM</span> SC;<br></code></pre></td></tr></table></figure><h5 id="查询满足条件的元组-where">查询满足条件的元组 WHERE</h5><ul><li><strong>比较大小</strong>，<span class="math inline">\(!&gt;\)</span>（不大于），<span class="math inline">\(!&lt;\)</span>(不小于)</li><li><strong>确定范围</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WHERE</span> Sage [<span class="hljs-keyword">NOT</span>] <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">20</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">30</span>; <span class="hljs-comment">/*包含边界*/</span><br></code></pre></td></tr></table></figure></li><li><strong>确定集合</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WHERE</span> Sdept [<span class="hljs-keyword">NOT</span>] <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;CS&#x27;</span>,<span class="hljs-string">&#x27;MA&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><strong>字符匹配</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">[<span class="hljs-keyword">NOT</span>] <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;&lt;匹配串&gt;&#x27;</span> [<span class="hljs-keyword">ESCAPE</span><span class="hljs-string">&#x27;&lt;换码字符&gt;&#x27;</span>]<br></code></pre></td></tr></table></figure><ul><li><span class="math inline">\(\%\)</span> 表示任意长度（长度可以为 0）的字符串</li><li><span class="math inline">\(\_\)</span> 表示单个字符</li><li><code>ESCAPE '&lt;换码字符&gt;'</code>对通配符进行转义 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WHERE</span> Cname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;DB\_%i__&#x27;</span> <span class="hljs-keyword">ESCAPE</span> <span class="hljs-string">&#x27;\&#x27;</span><br></code></pre></td></tr></table></figure> <code>\</code>为换码字符，第一个<code>_</code>为普通字符，后两个为通配符</li></ul></li><li><strong>涉及空值的查询</strong> <code>IS [NOT] NULL</code></li><li><strong>多重条件查询</strong> <code>AND</code> <code>OR</code><ul><li>AND 的优先级高于 OR，可以用括号</li></ul></li></ul><h4 id="order-by-子句">ORDER BY 子句</h4><p>对一个或多个属性列的升序或降序排列</p><p><strong>空值最大</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Grade <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h4 id="聚集函数">聚集函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)                        <span class="hljs-comment">/*统计元组个数*/</span><br><span class="hljs-built_in">COUNT</span>([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)     <span class="hljs-comment">/*统计一列中值的个数*/</span><br><span class="hljs-built_in">SUM</span> ([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)      <span class="hljs-comment">/*总和（此列必须数值型）*/</span><br><span class="hljs-built_in">AVG</span> ([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)      <span class="hljs-comment">/*平均值*/</span><br><span class="hljs-built_in">MAX</span> ([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)      <span class="hljs-comment">/*最大值*/</span><br><span class="hljs-built_in">MIN</span> ([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)      <span class="hljs-comment">/*最小值*/</span><br></code></pre></td></tr></table></figure><p><strong>除 COUNT(*)，都跳过空值只处理非空值</strong></p><p>WHERE 子句是不能用聚集函数做条件表达式的，<strong>聚集函数只能用于 SELECT 子句和 GROUP BY 中的 HAVING 子句</strong></p><h4 id="group-by-子句">GROUP BY 子句</h4><p><strong>例：求各个课程号及相应的选课人数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Cno, <span class="hljs-built_in">COUNT</span>(Sno)<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Cno;<br></code></pre></td></tr></table></figure><p>结果</p><table><thead><tr class="header"><th>Cno</th><th>COUNT(Sno)</th></tr></thead><tbody><tr class="odd"><td>1</td><td>22</td></tr><tr class="even"><td>2</td><td>34</td></tr></tbody></table><h5 id="用-having-短语对组进行筛选">用 HAVING 短语对组进行筛选</h5><p><strong>WHERE</strong>与<strong>HAVING</strong>的区别：</p><ul><li><strong>WHERE</strong>作用于基本表或视图</li><li><strong>HAVING</strong>作用于组，从而选择满足条件的组（非属性约束）</li></ul><p><span style="color:red">下面语句是不对的：</span></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sno,<span class="hljs-built_in">AVG</span>(Grade)<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">AVG</span>(Grade)<span class="hljs-operator">&gt;=</span><span class="hljs-number">90</span>    <span class="hljs-comment">/*WHERE子句不能用聚集函数做条件表达式*/</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno;<br></code></pre></td></tr></table></figure><p>正确应是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sno,<span class="hljs-built_in">AVG</span>(Grade)<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(Grade)<span class="hljs-operator">&gt;=</span><span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure><h3 id="连接查询">连接查询</h3><h4 id="等值与非等值连接自然连接">等值与非等值连接，自然连接</h4><p>运算符为<code>=</code>时为<strong>等值</strong>，其余为<strong>非等值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Student.<span class="hljs-operator">*</span>,SC.<span class="hljs-operator">*</span>       <span class="hljs-comment">/*.*某表中的所有属性列*/</span><br><span class="hljs-keyword">FROM</span> Student,SC<br><span class="hljs-keyword">WHERE</span> Student.Sno<span class="hljs-operator">=</span>SC.Sno    <span class="hljs-comment">/*Student与 SC中同一学生的元组连接起来*/</span><br></code></pre></td></tr></table></figure><p><strong>自然连接</strong>：把目标列中重复的属性列去掉（两表中的 Sno 相同）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade<br><span class="hljs-keyword">FROM</span> Student,SC<br><span class="hljs-keyword">WHERE</span> Student.Sno<span class="hljs-operator">=</span>SC.Sno<br></code></pre></td></tr></table></figure><h4 id="自身连接">自身连接</h4><p>为表取两个别名，<code>FIRST</code>和<code>SECOND</code></p><p><strong>例：对同一个表的 Cno 和 Cpno 连接</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> FIRST.Cno, SECOND.Cpno<br><span class="hljs-keyword">FROM</span> Course <span class="hljs-keyword">FIRST</span>, Course <span class="hljs-keyword">SECOND</span><br><span class="hljs-keyword">WHERE</span> FIRST.Cpno<span class="hljs-operator">=</span>SECOND.Cno;<br></code></pre></td></tr></table></figure><h4 id="外连接">外连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade<br><span class="hljs-keyword">FROM</span> Student <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> SC <span class="hljs-keyword">ON</span>(Student.Sno<span class="hljs-operator">=</span>SC.Sno)<br><span class="hljs-comment">/*也可以用USING连接：FROM Student LEFT OUTER JOIN SC USING(Sno);*/</span><br></code></pre></td></tr></table></figure><ul><li>左外连接 <code>LEFT OUTER</code></li><li>右外连接 <code>RIGHT OUTER</code></li></ul><h4 id="多表连接">多表连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WHERE</span> Student.Sno<span class="hljs-operator">=</span>SC.Sno <span class="hljs-keyword">AND</span> SC.Cno<span class="hljs-operator">=</span>Course.Cno<br></code></pre></td></tr></table></figure><h3 id="嵌套查询">嵌套查询</h3><h4 id="带有-in-的子查询">带有 IN 的子查询</h4><p>子查询是个集合时</p><h4 id="带有比较运算符的子查询">带有比较运算符的子查询</h4><p>子查询返回单个值时</p><h4 id="带有-anysome或-all-谓词的子查询">带有 ANY（SOME）或 ALL 谓词的子查询</h4><table><thead><tr class="header"><th>&gt; ANY</th><th>大于子查询结果某个值</th><th>等价于 &gt;MIN</th></tr></thead><tbody><tr class="odd"><td>&gt; ALL</td><td>大于子查询结果所有值</td><td>等价于 &gt;MAX</td></tr><tr class="even"><td>&lt;ANY</td><td>小于子查询结果某个值</td><td>等价于 &lt;MAX</td></tr><tr class="odd"><td>&lt; ALL</td><td>小于子查询结果所有值</td><td>等价于 &lt;MIN</td></tr><tr class="even"><td>&gt;= ANY</td><td>大于等于某个值</td><td></td></tr><tr class="odd"><td>&gt;= ALL</td><td>大于等于所有值</td><td></td></tr><tr class="even"><td>&lt;= ANY</td><td>小于等于某个值</td><td></td></tr><tr class="odd"><td>&lt;= ALL</td><td>小于等于所有值</td><td></td></tr><tr class="even"><td>= ANY</td><td>等于某个值</td><td>等价于 IN</td></tr><tr class="odd"><td>= ALL</td><td>等于所有值（通常没有实际意义）</td><td></td></tr><tr class="even"><td>!= (&lt;&gt;) ANY</td><td>不等于某个值</td><td></td></tr><tr class="odd"><td>!= (&lt;&gt;) ALL</td><td>不等于任何一个值</td><td>等价于 NOT IN</td></tr></tbody></table><p><strong>例：查询非计算机系中比计算机系任意一个学生年龄小的学生姓名和年龄</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname, Sage<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sage<span class="hljs-operator">&lt;</span><span class="hljs-keyword">ANY</span>(<span class="hljs-keyword">SELECT</span> Sage          <span class="hljs-comment">/*子查询块*/</span><br>                <span class="hljs-keyword">FROM</span> Student        <span class="hljs-comment">/*查询计算机系所有学生的年龄*/</span><br>                <span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span>)<br><span class="hljs-keyword">AND</span> Sdept <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;CS&#x27;</span>                   <span class="hljs-comment">/*父查询块中的条件*/</span><br></code></pre></td></tr></table></figure><h4 id="带有-exists-谓词的子查询">带有 EXISTS 谓词的子查询</h4><p>若内层查询结果非空，则外层的 WHERE 子句返回真值，否则返回假值</p><p><code>NOT EXISTS</code>相反</p><p><strong>例：查询所有选修了 1 号课程的学生姓名</strong></p><blockquote><p>在 Student 中依次取每个元组的 Sno 值，用此值去检查 SC 表</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span><br>    (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> SC<br>    <span class="hljs-keyword">WHERE</span> Sno<span class="hljs-operator">=</span>Student.Sno <span class="hljs-keyword">AND</span> Cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>例：查询选修了全部课程的学生姓名（全称转换为存在）</strong></p><blockquote><p>SQL 中没有全称量词（for all），可将题目的意思转换成等价的用存在量词的形式 本题中，题目意思转换成：查询这样的学生，没有一门课程是他不选修的</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span><br>        (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Course<br>         <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span><br>                (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> SC<br>                 <span class="hljs-keyword">WHERE</span> Sno<span class="hljs-operator">=</span>Student.Sno<br>                    <span class="hljs-keyword">AND</span> Cno<span class="hljs-operator">=</span>Course.Cno));<br></code></pre></td></tr></table></figure><p><strong>例：查询至少选修了学生 201215122 选修的全部课程的学生号码（逻辑蕴涵转换为存在）</strong></p><blockquote><p>SQL 中没有蕴涵逻辑运算，蕴涵谓词转换<span class="math inline">\(p \to q\equiv \neg p\vee q\)</span></p><p>分析：</p></blockquote><ul><li>本题语义为：查询学号为 x 的学号的学生，对所有课程 y，只要 201215122 学生选修了课程 y，则 x 也选修了 y。</li><li>形式化表示：<ul><li>p：“学生 201215122 选修了课程 y”</li><li>q：“学生 x 选修了课程 y”</li></ul></li><li>则上述查询为 <span class="math inline">\((\exists y )p\to q\)</span></li><li><span style="background-color:#C8D5F8"><span class="math inline">\((\exists y)p \to q\equiv \neg (\exists y\neg (p\to q)) \equiv\neg(\exists y(\neg(\neg p \vee q)))\equiv \neg \exists y(p \wedge \neg q)\)</span><span></li></ul><p>即：不存在这样的课程 y，学生 201215122 选修了 y，而学生 x 没有选</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> Sno<br><span class="hljs-keyword">FROM</span> SC SCX         <span class="hljs-comment">/*SC另称为SCX，以下同*/</span><br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span><br>        (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> SC SCY       <span class="hljs-comment">/*查询课程表SC中201215122选修的全部课程*/</span><br>         <span class="hljs-keyword">WHERE</span> SCY.Sno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;201215122&#x27;</span><br>         <span class="hljs-keyword">AND</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span><br>                (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> SC SCZ   <span class="hljs-comment">/*学生x选择了SCY筛选出来的即201215122学生学的课程*/</span><br>                 <span class="hljs-keyword">WHERE</span> SCZ.Sno<span class="hljs-operator">=</span>SCX.Sno<br>                 <span class="hljs-keyword">AND</span> SCZ.Cno<span class="hljs-operator">=</span>SCY.Cno))<br></code></pre></td></tr></table></figure><h3 id="集合查询">集合查询</h3><p>参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同</p><h4 id="union-并操作">UNION 并操作</h4><p><strong>例：查询计算机系的学生及年龄不大于 19 岁的学生</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span><br><span class="hljs-keyword">UNION</span>   <span class="hljs-comment">/*求并集*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sage<span class="hljs-operator">&lt;=</span><span class="hljs-number">19</span>;<br></code></pre></td></tr></table></figure><p>UNION 会<strong>自动去掉重复元组</strong>，要保留重复元组则用<code>UNION ALL</code>操作符</p><h4 id="intersect-交操作">INTERSECT 交操作</h4><p><strong>例：查询计算机系的学生与年龄不大于 19 岁的学生的交集</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span><br><span class="hljs-keyword">INTERSECT</span>   <span class="hljs-comment">/*求交集*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sage<span class="hljs-operator">&lt;=</span><span class="hljs-number">19</span>;<br></code></pre></td></tr></table></figure><p>实际上就是查询计算机系年龄不大于 19 岁的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span><br>        <span class="hljs-keyword">AND</span> Sage<span class="hljs-operator">&lt;=</span><span class="hljs-number">19</span>;<br></code></pre></td></tr></table></figure><h4 id="except-差操作">EXCEPT 差操作</h4><p><strong>例：查询计算机系的学生与年龄不大于 19 岁的学生的差集</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span><br><span class="hljs-keyword">EXCEPT</span>      <span class="hljs-comment">/*求差集*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sage<span class="hljs-operator">&lt;=</span><span class="hljs-number">19</span>;<br></code></pre></td></tr></table></figure><p>也就是查询计算机系中年龄大于 19 岁的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span> <span class="hljs-keyword">AND</span> Sage<span class="hljs-operator">&gt;</span><span class="hljs-number">19</span>;<br></code></pre></td></tr></table></figure><hr /><p>对集合操作结果的排序 <code>order by 1</code>(对第一列进行排序)，只能放在语句的最后</p><h3 id="基于派生表的查询">基于派生表的查询</h3><p>子查询出现在 FROM 子句中，生成临时派生表</p><p><strong>例：找出每个学生超过他自己选修课程平均成绩的课程号</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sno,Cno<br><span class="hljs-keyword">FROM</span> SC,(<span class="hljs-keyword">SELECT</span> Sno, <span class="hljs-built_in">AVG</span>(Grade) <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno)<br>        <span class="hljs-keyword">AS</span> Avg_sc(avg_sno, avg_grade)       <span class="hljs-comment">/*生成一个派生表Avg_sc，由avg_sno和avg_grade组成*/</span><br><span class="hljs-keyword">WHERE</span> SC.Sno<span class="hljs-operator">=</span>Avg_sc.avg_sno                 <span class="hljs-comment">/*按学号相等进行连接*/</span><br>        <span class="hljs-keyword">AND</span> SC.grade <span class="hljs-operator">&gt;=</span> Avg_sc.avg_grade    <span class="hljs-comment">/*选出修课成绩大于其平均成绩的课程号*/</span><br></code></pre></td></tr></table></figure><p>如果子查询中没有聚集函数，派生表可以不指定属性列</p><p><strong>例：查询所有选修了 1 号课程的学生姓名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname<br><span class="hljs-keyword">FROM</span> Student, (<span class="hljs-keyword">SELECT</span> Sno <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> Cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">AS</span> SC1<br><span class="hljs-keyword">WHERE</span> Student.Sno<span class="hljs-operator">=</span>SC1.Sno;<br></code></pre></td></tr></table></figure><p>通过 FROM 子句生成派生表时。<strong><code>AS</code>关键字可省略，但必须为派生关系指定一个别名</strong></p><h2 id="数据更新">数据更新</h2><h3 id="插入数据">插入数据</h3><p>执行插入语句时会检查所插入元组是否破坏已定义的完整性</p><h4 id="插入元组">插入元组</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>[(<span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]...)]<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-operator">&lt;</span>常量<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>常量<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]...);<br></code></pre></td></tr></table></figure><ul><li>INTO 子句中没有出现的属性列，新元组在这些列上会取空值</li><li>表定义时说明了 NOT NULL 的属性列不能取空值否则会出错</li><li>INTO 子句没有指明任何属性列，则新插入的元组必须在每个属性列上均有值，且顺序要和 CREATE TABLE 中的次序相同</li><li>指明了的属性列的顺序可以和 CREATE TABLE 中的顺序不一样</li><li><strong>字符串常量要用<code>’‘</code>括起来</strong></li><li>明确空值<code>NULL</code></li></ul><p><strong>例：将学生张承敏的信息插入到 Student 表中</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> Student        <span class="hljs-comment">/*没有指定属性列，则每个属性都要有值*/</span><br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;201215126&#x27;</span>,<span class="hljs-string">&#x27;张成民&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;CS&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="插入子查询结果一次性插入多个元组">插入子查询结果（一次性插入多个元组）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>...]]<br>子查询;<br></code></pre></td></tr></table></figure><p><strong>例：对每一个系求学生的平均年龄并把系名和平均年龄存入表中</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> Dept_age(Sdept,Avg_age)<br><span class="hljs-keyword">SELECT</span> Sdept,<span class="hljs-built_in">AVG</span>(age)<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sdept;         <span class="hljs-comment">/*按系分组求每个系的平均年龄*/</span><br></code></pre></td></tr></table></figure><h3 id="修改数据">修改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">SET</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;=</span><span class="hljs-operator">&lt;</span>表达式<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;=</span><span class="hljs-operator">&lt;</span>表达式<span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件<span class="hljs-operator">&gt;</span>];       <span class="hljs-comment">/*如果省略则表示要修改表中的所有元组*/</span><br></code></pre></td></tr></table></figure><h4 id="修改某一个元组的值">修改某一个元组的值</h4><p>例：将学生 201215121 的年龄改为 22 岁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> Student<br><span class="hljs-keyword">SET</span> Sage<span class="hljs-operator">=</span><span class="hljs-number">22</span><br><span class="hljs-keyword">WHERE</span> Sno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;201215121&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="修改多个元组的值">修改多个元组的值</h4><p>例：将所有学生的年龄增加 1 岁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> Student<br><span class="hljs-keyword">SET</span> Sage<span class="hljs-operator">=</span>Sage<span class="hljs-operator">+</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h4 id="带子查询的修改语句">带子查询的修改语句</h4><p>子查询嵌套在 UPDATE 语句中，用以构造修改的条件</p><p>例：将计算机系全体学生的成绩置零</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> SC<br><span class="hljs-keyword">SET</span> Grade<span class="hljs-operator">=</span><span class="hljs-number">0</span><br><span class="hljs-keyword">WHERE</span> Sno <span class="hljs-keyword">IN</span><br>        (<span class="hljs-keyword">SELECT</span> Sno<br>         <span class="hljs-keyword">FROM</span> Student<br>         <span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">WHERE语句等同于：</span><br><span class="hljs-comment">WHERE &#x27;CS&#x27;=(SELECT Sdept FROM Student</span><br><span class="hljs-comment">            WHERE Student.Sno=SC.Sno);</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="删除数据">删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件<span class="hljs-operator">&gt;</span>];   <span class="hljs-comment">/*省略WHERE子句删除的是表中全部元组，但不删除表的定义*/</span><br></code></pre></td></tr></table></figure><h4 id="删除某一个元组的值">删除某一个元组的值</h4><p>例：删除学号为 201215128 的学生记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;201215128&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="删除多个元组的值">删除多个元组的值</h4><p>例：删除所有学生的选课记录（SC 成为了空表）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> SC;<br></code></pre></td></tr></table></figure><h4 id="带子查询的删除语句">带子查询的删除语句</h4><p>例：删除计算机系所有学生的选课记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> Sno <span class="hljs-keyword">IN</span><br>        (<span class="hljs-keyword">SELECT</span> Sno <span class="hljs-keyword">FROM</span> Student<br>         <span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="空值的处理">空值的处理</h2><p>判断：<code>IS NULL</code>、<code>IS NOT NULL</code></p><h3 id="空值的约束条件">空值的约束条件</h3><ul><li>属性定义中<strong>含有 NOT NULL</strong>的不能取空值</li><li>加了<strong>UNIQUE 限制</strong>的属性不能取空值</li><li><strong>码属性</strong>不能取空值</li></ul><h3 id="空值的算数运算比较运算逻辑运算">空值的算数运算，比较运算，逻辑运算</h3><ul><li>空值与另一个值（包括另一个空值）的<strong>算数运算</strong>结果为空值</li><li>空值与另一个值（包括另一个空值）的<strong>比较运算</strong>结果为 UNKNOWN</li><li>逻辑运算如下</li></ul><table><thead><tr class="header"><th style="text-align: center;">x y</th><th style="text-align: center;">x AND y</th><th style="text-align: center;">x OR y</th><th style="text-align: center;">NOT x</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">T U</td><td style="text-align: center;">U</td><td style="text-align: center;">T</td><td style="text-align: center;">F</td></tr><tr class="even"><td style="text-align: center;">U T</td><td style="text-align: center;">U</td><td style="text-align: center;">T</td><td style="text-align: center;">U</td></tr><tr class="odd"><td style="text-align: center;">U U</td><td style="text-align: center;">U</td><td style="text-align: center;">U</td><td style="text-align: center;">U</td></tr><tr class="even"><td style="text-align: center;">U F</td><td style="text-align: center;">F</td><td style="text-align: center;">U</td><td style="text-align: center;">U</td></tr><tr class="odd"><td style="text-align: center;">F U</td><td style="text-align: center;">F</td><td style="text-align: center;">U</td><td style="text-align: center;">T</td></tr></tbody></table><h2 id="视图">视图</h2><h3 id="定义视图">定义视图</h3><h4 id="建立视图">建立视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [(<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>]...)]<br><span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>子查询<span class="hljs-operator">&gt;</span>            <span class="hljs-comment">/*子查询可以是任意的SELECT语句*/</span><br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION]   <span class="hljs-comment">/*表示对视图进行UPDATE、INSERT、DELETE操作时要保证更新、插入</span><br><span class="hljs-comment">                        或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）*/</span><br></code></pre></td></tr></table></figure><p><strong>组成视图的属性列名或全部省略或全部指定</strong> 在下列情况中必须明确指定组成视图的所有列名</p><ul><li>目标列是聚集函数或列表达式</li><li>多表连接时选出了几个同名列做视图的字段</li><li>在视图中为某个列启用新的更合适的名字</li></ul><p><strong>例：建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> IS_Student<br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> Sno,Sname,Sage<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;IS&#x27;</span><br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION;<br></code></pre></td></tr></table></figure><p>视图不仅可以建立在一个或多个基本表上，也可以建立在一个或多个已定义好的视图上，或建立在基本表与视图上</p><p><strong>例：建立信息系选修了 1 号课程的学生的视图（包括学号、姓名、成绩）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> IS_S1(Sno,Sname,Grade)<br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> Student.Sno,Sname,Grade<br><span class="hljs-keyword">FROM</span> Student,SC<br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;IS&#x27;</span> <span class="hljs-keyword">AND</span><br>      Student.Sno<span class="hljs-operator">=</span>SC.Sno <span class="hljs-keyword">AND</span>    <span class="hljs-comment">/*对Student和SC进行连接*/</span><br>      SC.Cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span>;<br></code></pre></td></tr></table></figure><p>可以用带有虚拟列（表达式）、聚集函数、GROUP BY 子句的查询来定义视图</p><p><strong>例：将学生学号及平均成绩定义为一个视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> S_G(Sno,Gavg)<br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> Sno,<span class="hljs-built_in">AVG</span>(Grade)<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno;<br></code></pre></td></tr></table></figure><h4 id="删除视图">删除视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [CASCADE]<br><span class="hljs-comment">/*如果该视图还导出其他视图，CASCADE级联删除该视图以及由他导出的子图*/</span><br></code></pre></td></tr></table></figure><h3 id="查询视图">查询视图</h3><p>大部分情况与基本表相同</p><blockquote><p>由于 WHERE 子句中不能用聚集函数作为条件表达式，对于 WHERE 子句中带有聚集函数的视图的查询很可能出错，一般不使用视图而是使用基本表查询</p></blockquote><h3 id="更新视图">更新视图</h3><p>由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换为对基本表的更新</p><p>在定义视图时加上<code>WITH CHECK OPTION</code>子句，在视图上增删改数据时关系数据库管理系统会检查视图定义中的条件，不满足条件则拒绝执行该操作</p><ul><li><strong>不可更新的视图：</strong> 并不是所有视图都是可更新的，例如视图中有平均成绩这一列，是由成绩表的成绩计算而来，想要修改平均成绩为 90，但是不可能修改成绩表的成绩使得平均成绩为 90，此时视图就是不可更新的。</li><li><strong>不允许更新的视图：</strong> 与不可更新的视图不同的是，前者是理论上证明其不可更新，后者指实际系统不支持其更新，但其本身可能可以更新</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>关系数据库标准语言SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CH5 数据库完整性</title>
    <link href="/2022/12/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    <url>/2022/12/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库完整性">数据库完整性</h1><p>数据库完整性指数据的<strong>正确性、相容性</strong>和<strong>有效性</strong></p><p>为维护数据库的完整性，数据库管理系统需实现如下功能：</p><ul><li>提供定义完整性约束条件的机制</li><li>提供完整性检查方法</li><li>进行违约处理</li></ul><h2 id="实体完整性">实体完整性</h2><h3 id="定义实体完整性">定义实体完整性</h3><p>在 CREATE TABLE 中用<strong>PRIMARY KEY</strong>定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">Sno <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>) <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-comment">/*在列级定义主码*/</span><br><br><span class="hljs-keyword">PRIMARY</span> KEY(Sno)            <span class="hljs-comment">/*在表级定义主码*/</span><br><br><span class="hljs-keyword">PRIMARY</span> KEY(Sno,Cno)        <span class="hljs-comment">/*多个属性构成的码只能在表级定义*/</span><br></code></pre></td></tr></table></figure><h3 id="实体完整性检查">实体完整性检查</h3><ul><li>检查主码值是否唯一，不唯一则拒绝插入或修改</li><li>检查主码的各个属性是否为空，有一个为空就拒绝插入或修改</li></ul><h2 id="参照完整性">参照完整性</h2><p>增删改都可能破坏参照完整性</p><h3 id="定义参照完整性">定义参照完整性</h3><p>在 CREATE TABLE 中用<strong>FOREIGN KEY</strong>短语定义哪些列为外码，用<strong>REFERENCES</strong>短语指明这些外码参照哪些表的主码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> SC<br>    (Sno <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>     Cno <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>     Grade <span class="hljs-type">SMALLINT</span>,<br>     <span class="hljs-keyword">PRIMARY</span> KEY(Sno,Cno),                      <span class="hljs-comment">/*表级定义实体完整性*/</span><br>     <span class="hljs-keyword">FOREIGN</span> KEY(Sno) <span class="hljs-keyword">REFERENCES</span> Student(Sno),  <span class="hljs-comment">/*表级定义参照完整性*/</span><br>     <span class="hljs-keyword">FOREIGN</span> KEY(Cno) <span class="hljs-keyword">REFERENCES</span> Course(Cno)    <span class="hljs-comment">/*表级定义参照完整性*/</span><br>    );<br></code></pre></td></tr></table></figure><h3 id="参照完整性检查和违约处理">参照完整性检查和违约处理</h3><table><thead><tr class="header"><th>被参照表</th><th>参照表</th><th>违约处理</th></tr></thead><tbody><tr class="odd"><td>可能破坏参照完整性</td><td>插入元组</td><td>拒绝</td></tr><tr class="even"><td>可能破坏参照完整性</td><td>修改外码值</td><td>拒绝</td></tr><tr class="odd"><td>删除元组</td><td>可能破坏参照完整性</td><td>拒绝(NO ACTION)/级联删除(CASCADE)/设置为空值</td></tr><tr class="even"><td>修改主码值</td><td>可能破坏参照完整性</td><td>拒绝(NO ACTION)/级联删除(CASCADE)/设置为空值</td></tr></tbody></table><p><strong>显式说明参照完整性的违约处理示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> SC<br>    (Sno <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>),<br>     Cno <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>),<br>     Grade <span class="hljs-type">SMALLINT</span>,<br>     <span class="hljs-keyword">PRIMARY</span> KEY(Sno, Cno),     <span class="hljs-comment">/*在表级定义实体完整性，Sno，Cno都不能取空值*/</span><br>     <span class="hljs-keyword">FOREIGN</span> KEY(Sno) <span class="hljs-keyword">REFERENCES</span> Student(Sno)   <span class="hljs-comment">/*表级定义参照完整性*/</span><br>        <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE<br>                        <span class="hljs-comment">/*当删除Student表中的元组时，级联删除SC表中相应的元组*/</span><br>        <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE<br>                        <span class="hljs-comment">/*当更新Student表中的元组时，级联更新SC表中相应的元组*/</span><br>     <span class="hljs-keyword">FOREIGN</span> KEY(Cno) <span class="hljs-keyword">REFERENCES</span> Course(Cno)<br>        <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">NO</span> ACTION<br>                        <span class="hljs-comment">/*当删除Course表中的元组造成SC表不一致时，拒绝删除*/</span><br>        <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE<br>                        <span class="hljs-comment">/*当更新Course表中的元组时，级联更新SC表中相应的元组*/</span><br>    );<br></code></pre></td></tr></table></figure><h2 id="用户定义的完整性">用户定义的完整性</h2><h3 id="属性上的约束条件">属性上的约束条件</h3><ul><li>列值非空(NOT NULL)</li><li>列值唯一(UNIQUE)</li><li>检查列值是否满足一个条件表达式（CHECK 语句） <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*性别属性Ssex只允许取‘男’或‘女’*/</span><br>Ssex <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">CHECK</span>(Ssex <span class="hljs-keyword">In</span>(<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>))<br></code></pre></td></tr></table></figure></li></ul><h3 id="元组上的约束条件">元组上的约束条件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*当性别为男时，其名字不能以Ms.开头*/</span><br><span class="hljs-keyword">CHECK</span>(Ssex<span class="hljs-operator">=</span><span class="hljs-string">&#x27;女&#x27;</span> <span class="hljs-keyword">OR</span> Sname <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Ms.%&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="完整性约束命名子句">完整性约束命名子句</h2><h3 id="定义完整性约束命名子句">定义完整性约束命名子句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-operator">&lt;</span>完整性约束条件名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>完整性约束条件<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>例：建立学生登记表 Student，要求学号在 9000 ～ 99999 之间，姓名不能取空值，年龄小于 30，性别只能是“男”或“女”</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student<br>    (Sno <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">6</span>)<br>        <span class="hljs-keyword">CONSTRAINT</span> C1 <span class="hljs-keyword">CHECK</span>(Sno <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">90000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">99999</span>)),<br>     Sname <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>)<br>        <span class="hljs-keyword">CONSTRAINT</span> C2 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>     Sage <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span>(Sage<span class="hljs-operator">&lt;</span><span class="hljs-number">30</span>),<br>     Ssex <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">CONSTRAINT</span> C4 <span class="hljs-keyword">CHECK</span> (Ssex <span class="hljs-keyword">IN</span>(<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>))，<br>     <span class="hljs-keyword">CONSTRAINT</span> StudentKey <span class="hljs-keyword">PRIMARY</span> KEY(Sno)<br></code></pre></td></tr></table></figure><h3 id="修改表中的完整性限制">修改表中的完整性限制</h3><p>使用<code>ALTER TABLE</code>修改表中的完整性限制</p><p>例：去掉上例 Student 表中对性别的限制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br>    <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> C4;<br></code></pre></td></tr></table></figure><p>修改约束条件需要先<code>DROP</code>原来的约束条件再<code>ADD</code>新约束条件</p><h2 id="触发器">触发器</h2><p>又叫作事件-条件-动作规则</p><h3 id="创建">创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span><br>&#123;BEFORE<span class="hljs-operator">|</span>AFTER&#125; <span class="hljs-operator">&lt;</span>触发器事件<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-comment">/*指明触发器激活的时间是在执行触发事件前或后*/</span><br><span class="hljs-keyword">REFERENCING</span> <span class="hljs-keyword">NEW</span><span class="hljs-operator">|</span><span class="hljs-keyword">OLD</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>变量<span class="hljs-operator">&gt;</span>   <span class="hljs-comment">/*REFERENCING指出引用的变量*/</span><br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span>&#123;<span class="hljs-type">ROW</span><span class="hljs-operator">|</span>STATEMENT&#125;            <span class="hljs-comment">/*定义触发器类型，行级触发器或语句级触发器*/</span><br>[<span class="hljs-keyword">WHEN</span> <span class="hljs-operator">&lt;</span>触发条件<span class="hljs-operator">&gt;</span>] <span class="hljs-operator">&lt;</span>触发动作体<span class="hljs-operator">&gt;</span>        <span class="hljs-comment">/*触发条件为真时才触发动作体*/</span><br></code></pre></td></tr></table></figure><p>同一表上多个触发器激活时遵循如下的执行顺序：</p><ol type="1"><li>执行该表上的 BEFORE 触发器</li><li>激活触发器的 SQL 语句</li><li>执行该表上的 AFTER 触发器</li></ol><h3 id="删除">删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>SQL语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CH4 数据库安全性</title>
    <link href="/2022/12/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <url>/2022/12/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库安全性">数据库安全性</h1><h2 id="概述">概述</h2><p>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改和破坏</p><h3 id="不安全因素">不安全因素</h3><ul><li>非授权用户对数据库的恶意存取和破坏</li><li>数据库中重要或敏感的数据被泄露</li><li>安全环境的脆弱性</li></ul><h2 id="数据库安全性控制">数据库安全性控制</h2><h3 id="存取控制">存取控制</h3><p>主要包括定义用户权限和合法权限检查两部分</p><p>C2 级的数据库管理系统支持自主存取控制（DAC），B1 级的数据库管理系统支持强制存取控制（MAC）</p><ul><li><strong>自主存取控制</strong>中，用户对不同的数据对象有不同的存取权限，不同的用户对同一对象也有不同权限，而且用户还可将其拥有的存取权限转授给其他用户，<strong>自主存取控制非常灵活</strong></li><li><strong>强制存储控制</strong>中，每一个数据库对象被标一定的密级，每一个用户也被授予某一个级别的许可证，对任一对象只有具有合法许可证的用户才可以存取，<strong>强制存取控制相对严格</strong></li></ul><h3 id="自主存取控制">自主存取控制</h3><p><strong>大型数据库管理系统都支持自主存取控制</strong>，SQL 通过 GRANT 和 REVOKE 语句来实现</p><p>列权限包括 SELECT，REFERENCES，INSERT，UPDATE</p><ul><li>对列的<u>UPDATE 权限</u>指对于表中存在的某一列的值可以进行修改，当然在<strong>修改的过程中要遵守表在创建时定义的主码及其他约束</strong></li><li>列上的<u>INSERT 权限</u>指用户可以插入一个元组。<strong>在给用户授予列 INSERT 权限时，一定要包含主码的 INSERT 权限</strong>，否则用户的插入动作会因为主码为空而被拒绝。</li></ul><h3 id="授权">授权</h3><h4 id="grant">GRANT</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...  <span class="hljs-comment">/*用户可以是一个或多个，或PUBLIC即全体用户*/</span><br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION]; <span class="hljs-comment">/*指定则获得某种权限的用户还可以把这个权限再授予其他用户*/</span><br></code></pre></td></tr></table></figure><p><strong>不允许循环授权！</strong></p><p>例：把对 Student 表和 Course 表的全部操作权限授予用户 U2 和 U3</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student,Course<br><span class="hljs-keyword">TO</span> U2,U3;<br></code></pre></td></tr></table></figure><p>例：把查询 Student 表和修改学生学号的权限授给用户 U4</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">UPDATE</span>(Sno),<span class="hljs-keyword">SELECT</span>    <span class="hljs-comment">/*对属性列授权时必须指定相应的属性列名*/</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">TO</span> U4;<br></code></pre></td></tr></table></figure><h4 id="revoke">REVOKE</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>[,[用户]]...[CASCADE<span class="hljs-operator">|</span>RESTRICT]<br></code></pre></td></tr></table></figure><ul><li><code>CASCADE</code>只收回直接或间接从该用户获取的权限的用户的该权限（意思是如果这个权限还有别的用户授予过来，那这个权限就不会被收回）</li></ul><h4 id="创建数据库模式的权限创建用户">创建数据库模式的权限（创建用户）</h4><p>GRANT 和 REVOKE 向用户授予或收回对数据的操作权限，对创建数据库模式一类的数据库对象的授权则由数据库管理员在创建用户时实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-operator">&lt;</span>username<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">WITH</span>][DBA<span class="hljs-operator">|</span>RESOURCE<span class="hljs-operator">|</span><span class="hljs-keyword">CONNECT</span>]<br></code></pre></td></tr></table></figure><p>只有系统的超级用户才有权创建一个新的数据库用户</p><table><thead><tr class="header"><th>拥有的权限</th><th>CREATE USER</th><th>CREATE SCHEMA</th><th>CREATE TABLE</th><th>登录数据库，执行数据查询和操纵</th></tr></thead><tbody><tr class="odd"><td>DBA</td><td>可以</td><td>可以</td><td>可以</td><td>可以</td></tr><tr class="even"><td>RESOURCE</td><td>不可以</td><td>不可以</td><td>可以</td><td>可以</td></tr><tr class="odd"><td>CONNECT</td><td>不可以</td><td>不可以</td><td>不可以</td><td>可以，但需拥有相应权限</td></tr></tbody></table><h3 id="数据库角色">数据库角色</h3><p>数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合，<strong>相同权限通过角色来授权</strong></p><p>PUBLIC 角色自动获得所有默认权限，不可删除/指派 每个 DB 用户都是成员，每个 DB 都有 PUBLIC 角色</p><h4 id="角色创建">角色创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ROLE <span class="hljs-operator">&lt;</span>角色名<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h4 id="给角色授权">给角色授权</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span>对象名<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...<br></code></pre></td></tr></table></figure><h4 id="将一个角色授予其他的角色或用户">将一个角色授予其他的角色或用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>角色<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-number">3</span><span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>用户<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WITH</span> ADMIN OPTION] <span class="hljs-comment">/*指定则获得某种权限的角色和用户可以把这个权限再授予其他角色*/</span><br></code></pre></td></tr></table></figure><h4 id="角色权限的收回">角色权限的收回</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...<br></code></pre></td></tr></table></figure><hr /><p><strong>例：通过角色实现将一组权限授予一个用户</strong></p><ol type="1"><li>首先创建一个角色 R1 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ROLE R1;<br></code></pre></td></tr></table></figure></li><li>使角色 R1 拥有 Student 表的 SELECT、UPDATE、INSERT 权限 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>,<span class="hljs-keyword">UPDATE</span>,<span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">TO</span> R1;<br></code></pre></td></tr></table></figure></li><li>将这个角色授予王平，张明，使他们拥有角色 R1 所包含的全部权限 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> R1<br><span class="hljs-keyword">TO</span> 王平，张明;<br></code></pre></td></tr></table></figure></li><li>可以一次性通过 R1 来收回王平的三个权限 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> R1<br><span class="hljs-keyword">FROM</span> 王平;<br></code></pre></td></tr></table></figure></li><li>角色权限的修改,使 R1 在原来的基础上增加了 DELETE 权限 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">TO</span> R1;<br></code></pre></td></tr></table></figure></li><li>角色权限的修改，使 R1 减少了 SELECT 权限 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">FROM</span> R1;<br></code></pre></td></tr></table></figure></li></ol><h3 id="强制存取控制">强制存取控制</h3><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类</p><ul><li><strong>主体是系统中的活动实体</strong>，包括数据库管理系统所管理的实际用户和代表用户的各进程</li><li><strong>客体是系统中的被动实体</strong>，受主体操纵，包括文件、基本表、索引、视图等</li></ul><p><strong>对于主体和客体，数据库管理系统为它们每个实例（值）指派一个敏感度标记</strong>，主体称为许可证级别，客体称为密级</p><p>次序：绝密(TS) &gt;= 机密(S) &gt;= 可信(C) &gt;= 公开(P)</p><ul><li>规则 1: 主体 &gt;= 相应的客体，能读取</li><li>规则 2: 主体 &lt;= 相应的客体，能写</li></ul><blockquote><p>按照规则 2，用户可以为写入的数据对象赋予高于自己的许可证级别的密级，这样一旦数据被写入该用户自己也不能再读该数据对象，如果违反规则 2，可能把数据的密级从高流向低，造成数据的泄露 例如，某个 TS 密级的主体把一个密级为 TS 的数据恶意将为 P，然后写回，这样原来是 TS 密级的数据大家都可以读到了，造成了 TS 密级数据的泄露</p></blockquote><p><strong>实现强制存取控制时要首先实现自主存取控制（DAC），即<u>自主存取控制与强制存取控制共同构成数据库管理系统的安全机制</u></strong></p><h2 id="视图机制">视图机制</h2><p>通过视图机制把要保密的数据对无权存取的用户隐藏起来，提高安全性</p><p>例：建立计算机系学生的视图，把对该视图的 SELECT 权限授予王平，把该视图上的所有操作权限授予张明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> CS_Student  <span class="hljs-comment">/*先建立视图，屏蔽计算机学生之外的数据*/</span><br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span>;<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>            <span class="hljs-comment">/*王平只能检索计算机系学生的数据*/</span><br><span class="hljs-keyword">ON</span> CS_Student<br><span class="hljs-keyword">TO</span> 王平;<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES    <span class="hljs-comment">/*张明有增删改查计算机系学生的所有权限*/</span><br><span class="hljs-keyword">ON</span> CS_Student<br><span class="hljs-keyword">TO</span> 张明;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>SQL语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
